<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZX Spectrum TOSEC Organizer</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin
        src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            font-family: system-ui, sans-serif;
        }

        .drag-over {
            background: rgba(34, 197, 94, 0.3) !important;
            border: 2px dashed #22c55e !important;
        }

        .file-row {
            cursor: grab;
            user-select: none;
        }

        .file-row:active {
            cursor: grabbing;
        }

        .file-row.dragging {
            opacity: 0.4;
        }
    </style>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const API_BASE = 'http://localhost:5000/api';

        const EMULABLE_EXT = ['.tap', '.tzx', '.z80', '.sna', '.dsk', '.trd', '.scl'];
        const OPENABLE_EXT = ['.pdf', '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.txt', '.doc', '.docx'];

        const Icon = ({ name, className = "w-5 h-5" }) => {
            const icons = {
                folder: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" /></svg>,
                file: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" /></svg>,
                terminal: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>,
                refresh: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>,
                check: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
                zap: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>,
                loader: <svg className={`${className} animate-spin`} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>,
                settings: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>,
                trash: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" /></svg>,
                plus: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" /></svg>,
                x: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>,
                copy: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>,
                search: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>,
                play: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>,
                open: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>,
                archive: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" /></svg>,
                upload: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" /></svg>,
                server: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 12h14M5 12a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v4a2 2 0 01-2 2M5 12a2 2 0 00-2 2v4a2 2 0 002 2h14a2 2 0 002-2v-4a2 2 0 00-2-2m-2-4h.01M17 16h.01" /></svg>,
                lock: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg>,
                wifi: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8.111 16.404a5.5 5.5 0 017.778 0M12 20h.01m-7.08-7.071c3.904-3.905 10.236-3.905 14.14 0M1.394 9.393c5.857-5.857 15.355-5.857 21.213 0" /></svg>,
                edit: <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
            };
            return icons[name] || icons.folder;
        };

        function App() {
            const [activeTab, setActiveTab] = useState('explorer');
            const [feStructure, setFeStructure] = useState(null);
            const [tsStructure, setTsStructure] = useState(null);
            const [fePath, setFePath] = useState([]);
            const [feItems, setFeItems] = useState([]);
            const [feLoading, setFeLoading] = useState(false);
            const [tsPath, setTsPath] = useState([]);
            const [tsItems, setTsItems] = useState([]);
            const [tsLoading, setTsLoading] = useState(false);
            // Colección seleccionada en cada panel del Explorador
            const [leftPanelCollection, setLeftPanelCollection] = useState('FE');
            const [rightPanelCollection, setRightPanelCollection] = useState('TS');
            // Rutas independientes para cada panel
            const [leftPath, setLeftPath] = useState([]);
            const [leftItems, setLeftItems] = useState([]);
            const [leftLoading, setLeftLoading] = useState(false);
            const [leftSelected, setLeftSelected] = useState([]);
            const [rightPath, setRightPath] = useState([]);
            const [rightItems, setRightItems] = useState([]);
            const [rightLoading, setRightLoading] = useState(false);
            const [rightSelected, setRightSelected] = useState([]);
            const [tempFiles, setTempFiles] = useState([]);
            const [rules, setRules] = useState([]);
            const [error, setError] = useState(null);
            const [success, setSuccess] = useState(null);
            
            // Auto-dismiss de notificaciones después de 3 segundos
            useEffect(() => {
                if (error) {
                    const timer = setTimeout(() => setError(null), 3000);
                    return () => clearTimeout(timer);
                }
            }, [error]);
            
            useEffect(() => {
                if (success) {
                    const timer = setTimeout(() => setSuccess(null), 3000);
                    return () => clearTimeout(timer);
                }
            }, [success]);
            
            const [copyLog, setCopyLog] = useState([]);
            const dragDataRef = useRef(null);
            const [showProcessModal, setShowProcessModal] = useState(false);
            const [selectedFile, setSelectedFile] = useState(null);
            const [selectedDestinations, setSelectedDestinations] = useState({ FE: [], TS: [] });
            const [processing, setProcessing] = useState(false);
            const [showFolderBrowser, setShowFolderBrowser] = useState(false);
            // Búsqueda universal
            const [showSearchModal, setShowSearchModal] = useState(false);
            const [searchQuery, setSearchQuery] = useState('');
            const [searchResults, setSearchResults] = useState([]);
            const [searching, setSearching] = useState(false);
            // Update package
            const [updateStatus, setUpdateStatus] = useState({ running: false, progress: '', done: false, error: null });
            const [updateResults, setUpdateResults] = useState([]);
            const [updateTargetCollection, setUpdateTargetCollection] = useState('TS');
            const [updatePreview, setUpdatePreview] = useState(null);
            // Estados para TEMP (copia a FE/TS reales)
            const [tempStatus, setTempStatus] = useState({ running: false, progress: '', done: false, error: null });
            const [tempResults, setTempResults] = useState([]);
            const [tempTargetCollection, setTempTargetCollection] = useState('TS');
            const [tempPreview, setTempPreview] = useState(null);
            const [browserPath, setBrowserPath] = useState([]);
            const [browserFolders, setBrowserFolders] = useState([]);
            const [browserCollection, setBrowserCollection] = useState('FE');
            const [currentRuleIndex, setCurrentRuleIndex] = useState(null);
            const [showFileBrowser, setShowFileBrowser] = useState(false);
            const [fileBrowserCollection, setFileBrowserCollection] = useState('TEMP');
            const [fileBrowserPath, setFileBrowserPath] = useState([]);
            const [fileBrowserItems, setFileBrowserItems] = useState([]);
            const [fileSearchFilter, setFileSearchFilter] = useState('');
            const [ruleSearchFilter, setRuleSearchFilter] = useState('');

            // Multicopy State
            const [mcSourceCollection, setMcSourceCollection] = useState('TEMP');
            const [mcSourcePath, setMcSourcePath] = useState([]);
            const [mcSourceItems, setMcSourceItems] = useState([]);
            const [mcSelectedItems, setMcSelectedItems] = useState([]); // {path, name, type, size, destinations: [{collection, path, pathDisplay}]}
            const [mcActiveItem, setMcActiveItem] = useState(null); // Item actualmente seleccionado para asignar destinos
            const [mcDestCollection, setMcDestCollection] = useState('FE');
            const [mcDestPath, setMcDestPath] = useState([]);
            const [mcDestItems, setMcDestItems] = useState([]);
            const [mcLoading, setMcLoading] = useState(false);
            const [mcPreview, setMcPreview] = useState(null);
            const [mcShowPreview, setMcShowPreview] = useState(false);
            const [mcExpandedItems, setMcExpandedItems] = useState([]); // Items expandidos en el panel central

            // Compresión
            const [compressCollection, setCompressCollection] = useState('FE');
            const [compressDestPath, setCompressDestPath] = useState('C:\\ZX\\Backups');
            const [compressVolumeSize, setCompressVolumeSize] = useState(3900);
            const [compressFormat, setCompressFormat] = useState('zip');
            const [compressing, setCompressing] = useState(false);
            const [compressProgress, setCompressProgress] = useState(null);

            // Backup NAS
            const [backupFiles, setBackupFiles] = useState([]);
            const [selectedBackupFiles, setSelectedBackupFiles] = useState([]);
            const [ftpPassword, setFtpPassword] = useState('');
            const [uploading, setUploading] = useState(false);
            const [uploadProgress, setUploadProgress] = useState([]);
            const [connectionStatus, setConnectionStatus] = useState(null);
            const [currentUploadFile, setCurrentUploadFile] = useState(null);
            const [selectedFilesFE, setSelectedFilesFE] = useState([]);
            const [selectedFilesTS, setSelectedFilesTS] = useState([]);

            useEffect(() => { 
                loadStructures(); 
                loadPanelContents('FE', [], setFeItems, setFeLoading);
                loadPanelContents('TS', [], setTsItems, setTsLoading);
                // Cargar paneles del explorador con contenido inicial
                loadPanelContents('FE', [], setLeftItems, setLeftLoading);
                loadPanelContents('TS', [], setRightItems, setRightLoading);
            }, []);

            // Polling del progreso de compresión
            useEffect(() => {
                let interval;
                if (compressing) {
                    interval = setInterval(async () => {
                        try {
                            const r = await fetch(`${API_BASE}/compress/status`);
                            const d = await r.json();
                            setCompressProgress(d);
                            if (d.done || d.error || !d.running) {
                                setCompressing(false);
                                if (d.done) setSuccess(d.progress);
                                if (d.error) setError(d.error);
                            }
                        } catch (e) { console.error('Error polling compress status:', e); }
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [compressing]);

            const loadStructures = async () => {
                try {
                    const [feRes, tsRes] = await Promise.all([fetch(`${API_BASE}/scan/FE`), fetch(`${API_BASE}/scan/TS`)]);
                    setFeStructure(await feRes.json());
                    setTsStructure(await tsRes.json());
                } catch (err) { setError('Error cargando estructuras'); }
            };

            const loadPanelContents = async (collection, pathArray, setItems, setLoading) => {
                setLoading(true);
                try {
                    const pathStr = pathArray.join('/');
                    // Si path está vacío, llamar al endpoint de raíz
                    const url = pathStr ? `${API_BASE}/browse/${collection}/${encodeURIComponent(pathStr)}` : `${API_BASE}/browse/${collection}`;
                    const response = await fetch(url);
                    const data = await response.json();
                    setItems(data.items || []);
                } catch (err) { setError(err.message); }
                finally { setLoading(false); }
            };

            const loadTempFiles = async () => { try { const r = await fetch(`${API_BASE}/temp/scan`); const d = await r.json(); setTempFiles(d.files || []); } catch (err) { setError(err.message); } };
            
            // Búsqueda universal
            const performSearch = async (query) => {
                if (!query || query.length < 2) return;
                setSearching(true);
                try {
                    const r = await fetch(`${API_BASE}/search?q=${encodeURIComponent(query)}`);
                    const d = await r.json();
                    setSearchResults(d.results || []);
                } catch (err) {
                    setError(err.message);
                }
                setSearching(false);
            };
            
            const navigateToSearchResult = (result) => {
                // Navegar a la ubicación del archivo
                const pathParts = result.relative_path.split('/').slice(0, -1); // Sin el nombre del archivo
                if (result.collection === 'FE') {
                    setFePath(pathParts);
                    loadPanelContents('FE', pathParts, setFeItems, setFeLoading);
                } else {
                    setTsPath(pathParts);
                    loadPanelContents('TS', pathParts, setTsItems, setTsLoading);
                }
                setShowSearchModal(false);
                setActiveTab('explorer');
            };
            
            // Copiar archivo a TEMP desde búsqueda
            const copySearchResultToTemp = async (result) => {
                if (!confirm(`¿Copiar "${result.name}" a TEMP?`)) return;
                try {
                    const r = await fetch(`${API_BASE}/copy-to-temp`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ source_path: result.full_path })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`Copiado a TEMP: ${result.name}`);
                    } else {
                        setError(d.error || 'Error al copiar');
                    }
                } catch (e) {
                    setError('Error: ' + e.message);
                }
            };
            
            // Emular archivo desde búsqueda
            const emulateSearchResult = async (result) => {
                try {
                    const r = await fetch(`${API_BASE}/emulator?path=${encodeURIComponent(result.full_path)}`);
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`🎮 Abriendo: ${result.name}`);
                    } else {
                        setError(d.error || 'Error al abrir emulador');
                    }
                } catch (e) {
                    setError('Error: ' + e.message);
                }
            };
            
            // Generar paquete de actualización
            const previewUpdatePackage = async () => {
                setUpdatePreview(null);
                setUpdateStatus({ running: false, progress: '', done: false, error: null });
                try {
                    const r = await fetch(`${API_BASE}/update/preview`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ target_collection: updateTargetCollection })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setUpdatePreview(d.files || []);
                    } else {
                        setUpdateStatus({ running: false, progress: '', done: false, error: d.error });
                    }
                } catch (e) {
                    setUpdateStatus({ running: false, progress: '', done: false, error: e.message });
                }
            };
            const generateUpdatePackage = async () => {
                setUpdateStatus({ running: true, progress: 'Copiando a UPDATES_TOSEC...', done: false, error: null });
                setUpdateResults([]);
                setUpdatePreview(null);
                try {
                    const r = await fetch(`${API_BASE}/update/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            target_collection: updateTargetCollection
                        })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setUpdateStatus({ running: false, progress: '', done: true, error: null });
                        setUpdateResults(d.results || []);
                        const successCount = (d.results || []).filter(r => r.success).length;
                        setSuccess(`Copiados ${successCount} archivos a ${updateTargetCollection} en UPDATES_TOSEC`);
                    } else {
                        setUpdateStatus({ running: false, progress: '', done: false, error: d.error });
                    }
                } catch (e) {
                    setUpdateStatus({ running: false, progress: '', done: false, error: e.message });
                }
            };
            // Funciones para TEMP (copia a FE/TS reales)
            const previewTempCopy = async () => {
                setTempPreview(null);
                setTempStatus({ running: false, progress: '', done: false, error: null });
                try {
                    const r = await fetch(`${API_BASE}/temp/preview`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ target_collection: tempTargetCollection })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setTempPreview(d.files || []);
                    } else {
                        setTempStatus({ running: false, progress: '', done: false, error: d.error });
                    }
                } catch (e) {
                    setTempStatus({ running: false, progress: '', done: false, error: e.message });
                }
            };
            const executeTempCopy = async () => {
                setTempStatus({ running: true, progress: 'Copiando a colección...', done: false, error: null });
                setTempResults([]);
                setTempPreview(null);
                try {
                    const r = await fetch(`${API_BASE}/temp/copy`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ target_collection: tempTargetCollection })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setTempStatus({ running: false, progress: '', done: true, error: null });
                        setTempResults(d.results || []);
                        const successCount = (d.results || []).filter(r => r.success).length;
                        setSuccess(`Copiados ${successCount} archivos a ${tempTargetCollection}`);
                        loadTempFiles(); // Recargar lista
                    } else {
                        setTempStatus({ running: false, progress: '', done: false, error: d.error });
                    }
                } catch (e) {
                    setTempStatus({ running: false, progress: '', done: false, error: e.message });
                }
            };
            const loadRules = async () => { try { const r = await fetch(`${API_BASE}/rules/load`); const d = await r.json(); setRules(d.rules || []); } catch (err) { setError(err.message); } };
            const saveRules = async () => { try { const r = await fetch(`${API_BASE}/rules/save`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ rules }) }); const d = await r.json(); if (d.success) setSuccess('Reglas guardadas'); } catch (err) { setError(err.message); } };
            const executeRules = async () => { setProcessing(true); try { const r = await fetch(`${API_BASE}/rules/execute`, { method: 'POST' }); const d = await r.json(); if (d.success) { setSuccess(d.message); loadTempFiles(); } else { setError(d.error || d.message); } } catch (err) { setError(err.message); } finally { setProcessing(false); } };
            const openFile = async (filePath) => { try { await fetch(`${API_BASE}/open-file`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ path: filePath }) }); } catch (err) { setError(err.message); } };

            // EMULADOR - Abre en nueva ventana
            const loadInEmulator = async (filePath, fileName) => {
                try {
                    const r = await fetch(`${API_BASE}/emulator?path=${encodeURIComponent(filePath)}`);
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`🎮 Abriendo: ${fileName}`);
                    } else {
                        setError(d.error || 'Error al abrir emulador');
                    }
                } catch (e) {
                    setError('Error: ' + e.message);
                }
            };

            // DRAG & DROP
            const handleDragStart = (e, item, sourceCollection) => { dragDataRef.current = { item, sourceCollection }; e.dataTransfer.effectAllowed = 'copy'; e.currentTarget.classList.add('dragging'); };
            const handleDragEnd = (e) => { e.currentTarget.classList.remove('dragging'); dragDataRef.current = null; };
            const handleDragOver = (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; };
            const handleDragEnter = (e) => { e.preventDefault(); e.currentTarget.classList.add('drag-over'); };
            const handleDragLeave = (e) => { e.currentTarget.classList.remove('drag-over'); };
            const handleDrop = async (e, destCollection, destPath) => {
                e.preventDefault(); e.currentTarget.classList.remove('drag-over');
                const dragData = dragDataRef.current;
                if (!dragData) { dragDataRef.current = null; return; }
                const { item, sourceCollection } = dragData;
                
                // Si es carpeta, pedir confirmación
                if (item.type === 'folder') {
                    const confirmMsg = `¿Copiar la carpeta "${item.name}" y todo su contenido de ${sourceCollection} a ${destCollection}/${destPath.join('/') || '(raíz)'}?`;
                    if (!confirm(confirmMsg)) { dragDataRef.current = null; return; }
                    
                    try {
                        const r = await fetch(`${API_BASE}/copy-folder`, { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ 
                                source_path: item.full_path, 
                                dest_collection: destCollection, 
                                dest_folder: destPath.join('/'),
                                folder_name: item.name
                            }) 
                        });
                        const d = await r.json();
                        if (d.success) {
                            setCopyLog(prev => [{ time: new Date().toLocaleTimeString(), file: `📁 ${item.name}`, from: sourceCollection, to: destCollection, dest: destPath.join('/') || '(raíz)' }, ...prev.slice(0, 49)]);
                            setSuccess(`✓ Carpeta ${item.name} copiada (${d.files_copied} archivos)`);
                            if (leftPanelCollection === destCollection) loadPanelContents(destCollection, leftPath, setLeftItems, setLeftLoading);
                            if (rightPanelCollection === destCollection) loadPanelContents(destCollection, rightPath, setRightItems, setRightLoading);
                        } else {
                            setError(d.error || 'Error al copiar carpeta');
                        }
                    } catch (err) { setError(err.message); }
                } else {
                    // Archivo normal
                    if (sourceCollection === destCollection) { dragDataRef.current = null; return; }
                    try {
                        const r = await fetch(`${API_BASE}/copy-between`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ source_path: item.full_path, dest_collection: destCollection, dest_folder: destPath.join('/') }) });
                        const d = await r.json();
                        if (d.success) {
                            setCopyLog(prev => [{ time: new Date().toLocaleTimeString(), file: item.name, from: sourceCollection, to: destCollection, dest: destPath.join('/') || '(raíz)' }, ...prev.slice(0, 49)]);
                            setSuccess(`✓ ${item.name} → ${destCollection}`);
                            if (leftPanelCollection === destCollection) loadPanelContents(destCollection, leftPath, setLeftItems, setLeftLoading);
                            if (rightPanelCollection === destCollection) loadPanelContents(destCollection, rightPath, setRightItems, setRightLoading);
                        }
                    } catch (err) { setError(err.message); }
                }
                dragDataRef.current = null;
            };

            // Navegación
            const clickFolderFE = (f) => { const np = [...fePath, f.name]; setFePath(np); setSelectedFilesFE([]); loadPanelContents('FE', np, setFeItems, setFeLoading); };
            const clickRootFE = (f) => { 
                setFePath([f.name]); 
                setSelectedFilesFE([]); 
                loadPanelContents('FE', [f.name], setFeItems, setFeLoading); 
                // También actualizar el panel izquierdo si muestra FE
                if (leftPanelCollection === 'FE') {
                    setLeftPath([f.name]);
                    setLeftSelected([]);
                    loadPanelContents('FE', [f.name], setLeftItems, setLeftLoading);
                }
                // O el panel derecho si muestra FE
                if (rightPanelCollection === 'FE') {
                    setRightPath([f.name]);
                    setRightSelected([]);
                    loadPanelContents('FE', [f.name], setRightItems, setRightLoading);
                }
            };
            const breadcrumbFE = (i) => { setSelectedFilesFE([]); if (i === -1) { setFePath([]); loadPanelContents('FE', [], setFeItems, setFeLoading); } else { const np = fePath.slice(0, i + 1); setFePath(np); loadPanelContents('FE', np, setFeItems, setFeLoading); } };
            const refreshFE = () => { loadPanelContents('FE', fePath, setFeItems, setFeLoading); loadStructures(); };
            const clickFolderTS = (f) => { const np = [...tsPath, f.name]; setTsPath(np); setSelectedFilesTS([]); loadPanelContents('TS', np, setTsItems, setTsLoading); };
            const clickRootTS = (f) => { 
                setTsPath([f.name]); 
                setSelectedFilesTS([]); 
                loadPanelContents('TS', [f.name], setTsItems, setTsLoading); 
                // También actualizar el panel izquierdo si muestra TS
                if (leftPanelCollection === 'TS') {
                    setLeftPath([f.name]);
                    setLeftSelected([]);
                    loadPanelContents('TS', [f.name], setLeftItems, setLeftLoading);
                }
                // O el panel derecho si muestra TS
                if (rightPanelCollection === 'TS') {
                    setRightPath([f.name]);
                    setRightSelected([]);
                    loadPanelContents('TS', [f.name], setRightItems, setRightLoading);
                }
            };
            const breadcrumbTS = (i) => { setSelectedFilesTS([]); if (i === -1) { setTsPath([]); loadPanelContents('TS', [], setTsItems, setTsLoading); } else { const np = tsPath.slice(0, i + 1); setTsPath(np); loadPanelContents('TS', np, setTsItems, setTsLoading); } };
            const refreshTS = () => { loadPanelContents('TS', tsPath, setTsItems, setTsLoading); loadStructures(); };
            
            // Funciones de navegación para panel izquierdo
            const clickFolderLeft = (f) => { const np = [...leftPath, f.name]; setLeftPath(np); setLeftSelected([]); loadPanelContents(leftPanelCollection, np, setLeftItems, setLeftLoading); };
            const clickRootLeft = (f) => { setLeftPath([f.name]); setLeftSelected([]); loadPanelContents(leftPanelCollection, [f.name], setLeftItems, setLeftLoading); };
            const breadcrumbLeft = (i) => { setLeftSelected([]); if (i === -1) { setLeftPath([]); loadPanelContents(leftPanelCollection, [], setLeftItems, setLeftLoading); } else { const np = leftPath.slice(0, i + 1); setLeftPath(np); loadPanelContents(leftPanelCollection, np, setLeftItems, setLeftLoading); } };
            const refreshLeft = () => { loadPanelContents(leftPanelCollection, leftPath, setLeftItems, setLeftLoading); };
            
            // Funciones de navegación para panel derecho
            const clickFolderRight = (f) => { const np = [...rightPath, f.name]; setRightPath(np); setRightSelected([]); loadPanelContents(rightPanelCollection, np, setRightItems, setRightLoading); };
            const clickRootRight = (f) => { setRightPath([f.name]); setRightSelected([]); loadPanelContents(rightPanelCollection, [f.name], setRightItems, setRightLoading); };
            const breadcrumbRight = (i) => { setRightSelected([]); if (i === -1) { setRightPath([]); loadPanelContents(rightPanelCollection, [], setRightItems, setRightLoading); } else { const np = rightPath.slice(0, i + 1); setRightPath(np); loadPanelContents(rightPanelCollection, np, setRightItems, setRightLoading); } };
            const refreshRight = () => { loadPanelContents(rightPanelCollection, rightPath, setRightItems, setRightLoading); };
            
            // Cambiar colección en panel (sin resetear la otra ventana)
            const switchLeftPanel = (col) => { 
                setLeftPanelCollection(col); 
                setLeftPath([]);
                setLeftSelected([]);
                loadPanelContents(col, [], setLeftItems, setLeftLoading);
            };
            const switchRightPanel = (col) => { 
                setRightPanelCollection(col);
                setRightPath([]);
                setRightSelected([]);
                loadPanelContents(col, [], setRightItems, setRightLoading);
            };

            // Funciones para crear carpeta
            const [showNewFolderModal, setShowNewFolderModal] = useState(false);
            const [newFolderName, setNewFolderName] = useState('');
            const [newFolderCollection, setNewFolderCollection] = useState('FE');

            const openNewFolderModal = (collection) => {
                setNewFolderCollection(collection);
                setNewFolderName('');
                setShowNewFolderModal(true);
            };

            const createNewFolder = async () => {
                if (!newFolderName.trim()) return;
                const basePath = newFolderCollection === 'FE' ? fePath : tsPath;
                try {
                    const r = await fetch(`${API_BASE}/folder/create`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            collection: newFolderCollection, 
                            path: basePath.join('/'),
                            name: newFolderName.trim()
                        })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`Carpeta "${newFolderName}" creada`);
                        setShowNewFolderModal(false);
                        setNewFolderName('');
                        // Refrescar paneles que muestren esta colección
                        if (leftPanelCollection === newFolderCollection) loadPanelContents(newFolderCollection, leftPath, setLeftItems, setLeftLoading);
                        if (rightPanelCollection === newFolderCollection) loadPanelContents(newFolderCollection, rightPath, setRightItems, setRightLoading);
                        loadStructures();
                    } else {
                        setError(d.error || 'Error al crear carpeta');
                    }
                } catch (e) { setError(e.message); }
            };

            // Funciones para borrar archivos seleccionados
            const deleteSelectedFiles = async (collection) => {
                const selected = collection === 'FE' ? selectedFilesFE : selectedFilesTS;
                if (selected.length === 0) return;
                if (!confirm(`¿Borrar ${selected.length} archivo(s)?`)) return;
                
                try {
                    const r = await fetch(`${API_BASE}/files/delete`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ files: selected })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`Borrados ${d.deleted} archivo(s)`);
                        if (collection === 'FE') { setSelectedFilesFE([]); refreshFE(); } 
                        else { setSelectedFilesTS([]); refreshTS(); }
                    } else {
                        setError(d.error);
                    }
                } catch (e) { setError(e.message); }
            };

            // Borrar carpeta
            const deleteFolder = async (collection, folderPath, folderName) => {
                // Preguntar directamente si quiere borrar con todo el contenido
                if (!confirm(`¿Borrar la carpeta "${folderName}" y TODO su contenido?\n\n⚠️ Esta acción NO se puede deshacer.`)) return;
                
                // Función para refrescar paneles después de borrar
                const refreshPanels = () => {
                    if (leftPanelCollection === collection) loadPanelContents(collection, leftPath, setLeftItems, setLeftLoading);
                    if (rightPanelCollection === collection) loadPanelContents(collection, rightPath, setRightItems, setRightLoading);
                    loadStructures();
                };
                
                try {
                    // Usar folderPath directamente ya que viene del item.full_path o construir desde el panel
                    const r = await fetch(`${API_BASE}/folder/delete`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            collection, 
                            full_path: folderPath,  // Enviar ruta completa
                            force: true  // Siempre forzar borrado
                        })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`Carpeta "${folderName}" eliminada`);
                        refreshPanels();
                    } else {
                        setError(d.error || 'Error al borrar carpeta');
                    }
                } catch (e) { setError(e.message); }
            };

            // Renombrar archivo o carpeta
            const renameFile = async (oldPath, oldName) => {
                const newName = prompt(`Renombrar "${oldName}":\n\nNuevo nombre:`, oldName);
                if (!newName || newName === oldName) return;
                
                try {
                    const r = await fetch(`${API_BASE}/files/rename`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ old_path: oldPath, new_name: newName })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`Renombrado: "${oldName}" → "${newName}"`);
                        refreshFE();
                        refreshTS();
                    } else {
                        setError(d.error || 'Error al renombrar');
                    }
                } catch (e) { setError(e.message); }
            };

            // Toggle selección de archivo
            const toggleFileSelection = (collection, filePath) => {
                if (collection === 'FE') {
                    setSelectedFilesFE(prev => prev.includes(filePath) ? prev.filter(f => f !== filePath) : [...prev, filePath]);
                } else {
                    setSelectedFilesTS(prev => prev.includes(filePath) ? prev.filter(f => f !== filePath) : [...prev, filePath]);
                }
            };
            
            // Selección para paneles izquierdo/derecho
            const toggleLeftSelection = (filePath) => {
                setLeftSelected(prev => prev.includes(filePath) ? prev.filter(f => f !== filePath) : [...prev, filePath]);
            };
            const toggleRightSelection = (filePath) => {
                setRightSelected(prev => prev.includes(filePath) ? prev.filter(f => f !== filePath) : [...prev, filePath]);
            };
            
            const deleteLeftSelected = async () => {
                if (leftSelected.length === 0) return;
                if (!confirm(`¿Borrar ${leftSelected.length} archivo(s)?`)) return;
                try {
                    const r = await fetch(`${API_BASE}/files/delete`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ files: leftSelected }) 
                    });
                    const d = await r.json();
                    if (d.success_count > 0) {
                        setSuccess(`${d.success_count} archivo(s) eliminados`);
                    }
                    setLeftSelected([]);
                    loadPanelContents(leftPanelCollection, leftPath, setLeftItems, setLeftLoading);
                    loadStructures();
                } catch (e) { setError(e.message); }
            };
            
            const deleteRightSelected = async () => {
                if (rightSelected.length === 0) return;
                if (!confirm(`¿Borrar ${rightSelected.length} archivo(s)?`)) return;
                try {
                    const r = await fetch(`${API_BASE}/files/delete`, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify({ files: rightSelected }) 
                    });
                    const d = await r.json();
                    if (d.success_count > 0) {
                        setSuccess(`${d.success_count} archivo(s) eliminados`);
                    }
                    setRightSelected([]);
                    loadPanelContents(rightPanelCollection, rightPath, setRightItems, setRightLoading);
                    loadStructures();
                } catch (e) { setError(e.message); }
            };

            const getFileExt = (name) => { const i = name.lastIndexOf('.'); return i > 0 ? name.substring(i).toLowerCase() : ''; };
            const isEmulable = (name) => EMULABLE_EXT.includes(getFileExt(name));
            const isOpenable = (name) => OPENABLE_EXT.includes(getFileExt(name));
            const formatSize = (bytes) => { if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB'; if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB'; return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB'; };

            // Reglas
            const deleteRule = (i) => { if (confirm('¿Eliminar?')) setRules(rules.filter((_, idx) => idx !== i)); };
            const addRule = () => setRules([...rules, { files: [], categories: [] }]);
            const addFileToRule = (ri) => { const nr = [...rules]; nr[ri].files.push(''); setRules(nr); };
            const updateFileInRule = (ri, fi, v) => { const nr = [...rules]; nr[ri].files[fi] = v; setRules(nr); };
            const removeFileFromRule = (ri, fi) => { const nr = [...rules]; nr[ri].files.splice(fi, 1); setRules(nr); };
            const addCategoryToRule = (ri) => { const nr = [...rules]; nr[ri].categories.push(''); setRules(nr); };
            const updateCategoryInRule = (ri, ci, v) => { const nr = [...rules]; nr[ri].categories[ci] = v; setRules(nr); };
            const removeCategoryFromRule = (ri, ci) => { const nr = [...rules]; nr[ri].categories.splice(ci, 1); setRules(nr); };
            const openFolderBrowser = (ri) => { setCurrentRuleIndex(ri); setBrowserPath([]); setBrowserCollection('FE'); loadBrowserFolders('FE', ''); setShowFolderBrowser(true); };
            const loadBrowserFolders = async (c, p) => { const url = p ? `${API_BASE}/browse-folders/${c}/${encodeURIComponent(p)}` : `${API_BASE}/browse-folders/${c}`; const r = await fetch(url); const d = await r.json(); setBrowserFolders(d.folders || []); };
            const loadFileBrowserContents = async (c, p) => {
                console.log('[DEBUG] loadFileBrowserContents called:', { collection: c, path: p });
                if (c === 'TEMP') {
                    const r = await fetch(`${API_BASE}/temp/scan`);
                    const d = await r.json();
                    console.log('[DEBUG] TEMP response:', d);
                    setFileBrowserItems((d.files || []).map(f => ({ ...f, type: 'file' })));
                } else {
                    // For FE/TS, we want to show files, not folders
                    // Use /api/browse/<collection>/<path> which returns both files and folders
                    const ps = (p || []).join('/');
                    const url = ps ? `${API_BASE}/browse/${c}/${encodeURIComponent(ps)}` : `${API_BASE}/scan/${c}`;
                    console.log('[DEBUG] FE/TS URL:', url);
                    const r = await fetch(url);
                    const d = await r.json();
                    console.log('[DEBUG] FE/TS response:', d);
                    // Show both folders and files, but mark them appropriately
                    const items = d.items || [];
                    console.log('[DEBUG] Items to display:', items);
                    setFileBrowserItems(items);
                }
            };


            // TEMP
            const deleteTempFile = async (fn) => { if (!confirm(`¿Eliminar ${fn}?`)) return; await fetch(`${API_BASE}/temp/delete`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: fn }) }); loadTempFiles(); setTempPreview(null); };
            
            const renameTempFile = async (oldPath, oldName) => {
                const newName = prompt(`Renombrar "${oldName}":\n\nNuevo nombre:`, oldName);
                if (!newName || newName === oldName) return;
                try {
                    const r = await fetch(`${API_BASE}/files/rename`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ old_path: oldPath, new_name: newName })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`Renombrado: "${oldName}" → "${newName}"`);
                        loadTempFiles();
                        setTempPreview(null); // Limpiar vista previa ya que cambió el nombre
                    } else {
                        setError(d.error || 'Error al renombrar');
                    }
                } catch (e) { setError(e.message); }
            };
            const openProcessModal = (f) => { setSelectedFile(f); setSelectedDestinations({ FE: f.suggested_paths?.FE || [], TS: f.suggested_paths?.TS || [] }); setShowProcessModal(true); };
            const processFile = async () => { 
                if (!selectedFile) return; 
                setProcessing(true); 
                const r = await fetch(`${API_BASE}/process-file`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ filename: selectedFile.name, destinations: selectedDestinations }) }); 
                const d = await r.json(); 
                setProcessing(false); 
                if (d.overall_success) { 
                    setSuccess('Copiado'); 
                    setShowProcessModal(false); 
                    loadTempFiles(); 
                    // Auto-refresh destinos
                    if (selectedDestinations.FE?.length > 0) refreshFE();
                    if (selectedDestinations.TS?.length > 0) refreshTS();
                } 
            };
            const toggleDestination = (c, p) => { setSelectedDestinations(prev => { const l = prev[c] || []; return l.includes(p) ? { ...prev, [c]: l.filter(x => x !== p) } : { ...prev, [c]: [...l, p] }; }); };

            // Compresión
            const startCompression = async () => {
                if (!compressDestPath) { setError('Falta ruta'); return; }
                setCompressing(true);
                setCompressProgress({ progress: 'Iniciando...', percent: 0 });
                try {
                    const r = await fetch(`${API_BASE}/compress/start`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ collection: compressCollection, dest_path: compressDestPath, volume_size_mb: compressVolumeSize, format: compressFormat }) });
                    const d = await r.json();
                    if (!d.success) { setError(d.error); setCompressing(false); }
                } catch (err) { setError(err.message); setCompressing(false); }
            };
            
            const cancelCompression = async () => {
                try {
                    await fetch(`${API_BASE}/compress/cancel`, { method: 'POST' });
                    // Resetear estado para volver a pantalla inicial
                    setCompressing(false);
                    setCompressProgress(null);
                    setSuccess('Compresión cancelada');
                } catch (err) { setError(err.message); }
            };

            // Backup NAS
            const loadBackupFiles = async () => { try { const r = await fetch(`${API_BASE}/backup/list-files`); const d = await r.json(); setBackupFiles(d.files || []); } catch (err) { setError(err.message); } };
            const toggleBackupFile = (name) => setSelectedBackupFiles(prev => prev.includes(name) ? prev.filter(n => n !== name) : [...prev, name]);
            const selectAllBackupFiles = () => setSelectedBackupFiles(backupFiles.map(f => f.name));
            const deselectAllBackupFiles = () => setSelectedBackupFiles([]);

            // Probar conexión FTP
            const testFtpConnection = async () => {
                if (!ftpPassword) { setError('Introduce la contraseña'); return; }
                setConnectionStatus({ status: 'testing', message: 'Probando conexión...' });
                try {
                    const r = await fetch(`${API_BASE}/backup/ftp-test`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ password: ftpPassword }) });
                    const d = await r.json();
                    if (d.success) {
                        setConnectionStatus({ status: 'ok', message: `✓ Conectado. Carpeta /ZxTosec: ${d.folder_exists ? 'existe' : 'no existe'}. ${d.remote_files?.length || 0} archivos remotos.` });
                    } else {
                        setConnectionStatus({ status: 'error', message: d.error });
                    }
                } catch (err) {
                    setConnectionStatus({ status: 'error', message: err.message });
                }
            };

            // Subir archivos uno por uno con progreso
            const uploadToNAS = async () => {
                if (!ftpPassword) { setError('Introduce la contraseña'); return; }
                if (selectedBackupFiles.length === 0) { setError('Selecciona archivos'); return; }

                setUploading(true);
                setUploadProgress([]);

                for (let i = 0; i < selectedBackupFiles.length; i++) {
                    const filename = selectedBackupFiles[i];
                    const fileInfo = backupFiles.find(f => f.name === filename);

                    setCurrentUploadFile({ name: filename, index: i + 1, total: selectedBackupFiles.length, size: fileInfo?.size || 0 });

                    try {
                        const r = await fetch(`${API_BASE}/backup/ftp-upload-single`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ password: ftpPassword, filename })
                        });
                        const d = await r.json();

                        setUploadProgress(prev => [...prev, {
                            filename,
                            success: d.success,
                            error: d.error,
                            size: d.size,
                            speed: d.speed_mbps,
                            elapsed: d.elapsed_seconds,
                            verified: d.verified
                        }]);
                    } catch (err) {
                        setUploadProgress(prev => [...prev, { filename, success: false, error: err.message }]);
                    }
                }

                setCurrentUploadFile(null);
                setUploading(false);
                setSelectedBackupFiles([]);

                const successCount = uploadProgress.filter(p => p.success).length;
                setSuccess(`Subida completada: ${successCount}/${selectedBackupFiles.length} archivos`);
            };

            const filteredRules = rules.filter(r => { if (!ruleSearchFilter) return true; const s = ruleSearchFilter.toLowerCase(); return r.files.some(f => f.toLowerCase().includes(s)) || r.categories.some(c => c.toLowerCase().includes(s)); });
            const panelHeight = 'calc((100vh - 130px) / 2)';

            const FileRow = ({ item, collection, onFolderClick, isSelected, onToggleSelect, onDeleteFolder, onRename }) => {
                const canEmulate = item.type === 'file' && isEmulable(item.name);
                const canOpen = item.type === 'file' && isOpenable(item.name);
                if (item.type === 'folder') {
                    return (<div draggable="true" onDragStart={(e) => handleDragStart(e, item, collection)} onDragEnd={handleDragEnd} className="p-1.5 rounded border text-xs flex items-center gap-1.5 bg-gray-800/50 border-gray-700/50 hover:border-cyan-500/50 group cursor-move">
                        <div onClick={() => onFolderClick(item)} className="flex-1 flex items-center gap-1.5 cursor-pointer">
                            <Icon name="folder" className="w-3.5 h-3.5 text-cyan-400" />
                            <span className="flex-1 truncate">{item.name}</span>
                            <span className="text-purple-400">{item.file_count?.toLocaleString()}</span>
                        </div>
                        <button onClick={(e) => { e.stopPropagation(); onRename && onRename(item.full_path, item.name); }} className="p-1 bg-blue-600/50 hover:bg-blue-500 rounded opacity-0 group-hover:opacity-100 transition-opacity" title="Renombrar"><Icon name="edit" className="w-2.5 h-2.5" /></button>
                        <button onClick={(e) => { e.stopPropagation(); onDeleteFolder && onDeleteFolder(collection, item.full_path, item.name); }} className="p-1 bg-red-600/50 hover:bg-red-500 rounded opacity-0 group-hover:opacity-100 transition-opacity" title="Borrar carpeta"><Icon name="trash" className="w-2.5 h-2.5" /></button>
                    </div>);
                }
                return (<div draggable="true" onDragStart={(e) => handleDragStart(e, item, collection)} onDragEnd={handleDragEnd} className={`file-row p-1.5 rounded border text-xs flex items-center gap-1.5 group ${isSelected ? 'bg-purple-600/40 border-purple-500' : 'bg-gray-800/50 border-gray-700/50 hover:border-purple-500/50'}`}>
                    <input type="checkbox" checked={isSelected} onChange={() => onToggleSelect && onToggleSelect(collection, item.full_path)} className="w-3 h-3 accent-purple-500" onClick={(e) => e.stopPropagation()} />
                    <Icon name="file" className={`w-3.5 h-3.5 ${canEmulate ? 'text-green-400' : canOpen ? 'text-orange-400' : 'text-gray-400'}`} />
                    <span className="flex-1 truncate" title={item.name}>{item.name}</span>
                    <span className="text-gray-500">{(item.size / 1024).toFixed(0)}K</span>
                    <button onClick={(e) => { e.stopPropagation(); onRename && onRename(item.full_path, item.name); }} className="p-1 bg-blue-600/50 hover:bg-blue-500 rounded opacity-0 group-hover:opacity-100 transition-opacity" title="Renombrar"><Icon name="edit" className="w-2.5 h-2.5" /></button>
                    {canEmulate && <button onClick={(e) => { e.stopPropagation(); loadInEmulator(item.full_path, item.name); }} className="p-1 bg-green-600 hover:bg-green-500 rounded" title="Emular"><Icon name="play" className="w-3 h-3" /></button>}
                    {canOpen && <button onClick={(e) => { e.stopPropagation(); openFile(item.full_path); }} className="p-1 bg-orange-600 hover:bg-orange-500 rounded" title="Abrir"><Icon name="open" className="w-3 h-3" /></button>}
                </div>);
            };

            // Multicopy Helpers
            const loadMcSourceContents = async (collection, pathArray) => {
                setMcLoading(true);
                try {
                    const pathStr = pathArray.join('/');
                    const url = pathStr ? `${API_BASE}/multicopy/browse/${encodeURIComponent(pathStr)}` : `${API_BASE}/multicopy/browse`;
                    // Note: The browse endpoint handles full paths. For root, we need to handle collection selection manually if browse returns all roots.
                    // Actually, browse returns [FE, TS, TEMP] at root. We want to browse *inside* a specific collection.
                    // Let's use the existing browse logic: if path is empty, we might need to construct the root path for the collection.

                    // Better approach: Use the existing browse endpoint but filter/direct based on collection.
                    // If pathArray is empty, we need the root of the collection.
                    let fullPath = 'ROOT';
                    if (pathArray.length > 0) {
                        // If we have a path, it's a full path from the API
                        fullPath = pathArray[pathArray.length - 1]; // The last item in pathArray should be the full path? 
                        // Wait, pathArray usually stores names. We need full paths for the API.
                        // Let's store full objects in path or just use the full path string.
                        // For simplicity, let's say pathArray stores the full path strings.
                        fullPath = pathArray[pathArray.length - 1];
                    } else {
                        // Root of collection
                        if (collection === 'TEMP') fullPath = 'c:\\ZX\\TEMP'; // We should get this from config or API, but hardcoding for now or fetching roots first.
                        // Actually, let's use the browse endpoint to get roots first, then filter.
                        // Or, we can just use the /api/scan/FE etc endpoints? No, multicopy/browse is better.

                        // Let's try: if path is empty, we ask for the collection root.
                        // The backend `multicopy_browse` returns roots if path is ROOT.
                        // We can just use the `full_path` from the item we clicked.
                        // Initial load: we need the root path of the collection.
                        // Let's assume we have the root paths available or we fetch them.
                        // Actually, let's just use the `multicopy_browse` with the known root paths if we can.
                        // But we don't know the root paths on frontend easily without fetching.

                        // Alternative: The `multicopy_browse` endpoint handles `ROOT` to give us [FE, TS, TEMP].
                        // We can fetch that once to get the base paths.
                    }

                    // Let's simplify: 
                    // 1. When switching collection, we load the root of that collection.
                    //    We can use the existing `feStructure` etc? No, `multicopy/browse` is for filesystem browsing.
                    //    Let's use `multicopy/browse/ROOT` to get the 3 roots, then pick the one matching `collection`.

                    if (pathArray.length === 0) {
                        const r = await fetch(`${API_BASE}/multicopy/browse`);
                        const d = await r.json();
                        // d.items contains the roots. Find the one matching collection.
                        const rootItem = d.items.find(i => i.name === `[${collection}]`);
                        if (rootItem) {
                            // Now load the contents of this root
                            const r2 = await fetch(`${API_BASE}/multicopy/browse/${encodeURIComponent(rootItem.full_path)}`);
                            const d2 = await r2.json();
                            setMcSourceItems(d2.items || []);
                            // We don't add root to path, we just show its contents.
                        }
                    } else {
                        const lastPath = pathArray[pathArray.length - 1];
                        const r = await fetch(`${API_BASE}/multicopy/browse/${encodeURIComponent(lastPath)}`);
                        const d = await r.json();
                        setMcSourceItems(d.items || []);
                    }
                } catch (e) { setError(e.message); }
                finally { setMcLoading(false); }
            };

            const loadMcDestContents = async (collection, pathArray) => {
                setMcLoading(true);
                try {
                    if (pathArray.length === 0) {
                        const r = await fetch(`${API_BASE}/multicopy/browse`);
                        const d = await r.json();
                        const rootItem = d.items.find(i => i.name === `[${collection}]`);
                        if (rootItem) {
                            const r2 = await fetch(`${API_BASE}/multicopy/browse/${encodeURIComponent(rootItem.full_path)}`);
                            const d2 = await r2.json();
                            setMcDestItems(d2.items || []);
                        }
                    } else {
                        const lastPath = pathArray[pathArray.length - 1];
                        const r = await fetch(`${API_BASE}/multicopy/browse/${encodeURIComponent(lastPath)}`);
                        const d = await r.json();
                        setMcDestItems(d.items || []);
                    }
                } catch (e) { setError(e.message); }
                finally { setMcLoading(false); }
            };

            // Funciones de gestión de archivos en Multicopia
            const mcDeleteItem = async (itemPath, itemName, isFolder) => {
                const msg = isFolder ? `¿Eliminar la carpeta "${itemName}" y todo su contenido?` : `¿Eliminar el archivo "${itemName}"?`;
                if (!confirm(msg)) return;
                
                try {
                    const r = await fetch(`${API_BASE}/files/delete`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ files: [itemPath] })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`Eliminado: ${itemName}`);
                        // Refrescar panel source
                        loadMcSourceContents(mcSourceCollection, mcSourcePath);
                        // Quitar de seleccionados si estaba
                        setMcSelectedFiles(mcSelectedFiles.filter(f => f !== itemPath));
                    } else {
                        setError(d.error || 'Error al eliminar');
                    }
                } catch (e) { setError(e.message); }
            };
            
            const mcRenameItem = async (itemPath, itemName) => {
                const newName = prompt(`Renombrar "${itemName}":\n\nNuevo nombre:`, itemName);
                if (!newName || newName === itemName) return;
                
                try {
                    const r = await fetch(`${API_BASE}/files/rename`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ old_path: itemPath, new_name: newName })
                    });
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`Renombrado: "${itemName}" → "${newName}"`);
                        loadMcSourceContents(mcSourceCollection, mcSourcePath);
                        // Actualizar seleccionados si estaba
                        if (mcSelectedFiles.includes(itemPath)) {
                            setMcSelectedFiles(mcSelectedFiles.map(f => f === itemPath ? d.new_path : f));
                        }
                    } else {
                        setError(d.error || 'Error al renombrar');
                    }
                } catch (e) { setError(e.message); }
            };
            
            const mcEmulateItem = async (itemPath, itemName) => {
                try {
                    const r = await fetch(`${API_BASE}/emulator?path=${encodeURIComponent(itemPath)}`);
                    const d = await r.json();
                    if (d.success) {
                        setSuccess(`🎮 Abriendo: ${itemName}`);
                    } else {
                        setError(d.error || 'Error al abrir emulador');
                    }
                } catch (e) { setError(e.message); }
            };
            
            // Añadir item a selección (con array de destinos vacío)
            const mcAddToSelection = (item) => {
                if (!mcSelectedItems.find(i => i.path === item.full_path)) {
                    const newItem = {
                        path: item.full_path,
                        name: item.name,
                        type: item.type,
                        size: item.size || 0,
                        destinations: []
                    };
                    setMcSelectedItems([...mcSelectedItems, newItem]);
                    setMcActiveItem(newItem); // Activar automáticamente para asignar destinos
                    setMcExpandedItems([...mcExpandedItems, item.full_path]); // Expandir automáticamente
                }
            };
            
            // Quitar item de selección
            const mcRemoveFromSelection = (path) => {
                setMcSelectedItems(mcSelectedItems.filter(i => i.path !== path));
                if (mcActiveItem?.path === path) setMcActiveItem(null);
                setMcExpandedItems(mcExpandedItems.filter(p => p !== path));
            };
            
            // Seleccionar item activo (para asignarle destinos)
            const mcSetActiveItem = (item) => {
                setMcActiveItem(mcActiveItem?.path === item.path ? null : item);
            };
            
            // Toggle expandir/contraer item
            const mcToggleExpand = (path) => {
                setMcExpandedItems(mcExpandedItems.includes(path) 
                    ? mcExpandedItems.filter(p => p !== path) 
                    : [...mcExpandedItems, path]);
            };
            
            // Añadir destino al item activo
            const mcAddDestinationToItem = async () => {
                if (!mcActiveItem) {
                    setError('Selecciona primero un item en el panel central');
                    return;
                }
                
                let fullPath = '';
                let pathDisplay = '';
                
                if (mcDestPath.length > 0) {
                    fullPath = mcDestPath[mcDestPath.length - 1];
                    pathDisplay = `${mcDestCollection}:/${mcDestPath.map(p => p.split(/[/\\]/).pop()).join('/')}`;
                } else {
                    const r = await fetch(`${API_BASE}/multicopy/browse`);
                    const d = await r.json();
                    const rootItem = d.items.find(i => i.name === `[${mcDestCollection}]`);
                    if (rootItem) {
                        fullPath = rootItem.full_path;
                        pathDisplay = `${mcDestCollection}:/`;
                    }
                }
                
                if (!fullPath) return;
                
                // Actualizar el item activo con el nuevo destino
                setMcSelectedItems(mcSelectedItems.map(item => {
                    if (item.path === mcActiveItem.path) {
                        // Verificar que no esté duplicado
                        if (item.destinations.find(d => d.path === fullPath)) {
                            setError('Este destino ya está asignado');
                            return item;
                        }
                        const updatedItem = {
                            ...item,
                            destinations: [...item.destinations, {
                                collection: mcDestCollection,
                                path: fullPath,
                                pathDisplay: pathDisplay
                            }]
                        };
                        setMcActiveItem(updatedItem);
                        return updatedItem;
                    }
                    return item;
                }));
                setSuccess(`Destino añadido a "${mcActiveItem.name}"`);
            };
            
            // Quitar destino de un item específico
            const mcRemoveDestinationFromItem = (itemPath, destPath) => {
                setMcSelectedItems(mcSelectedItems.map(item => {
                    if (item.path === itemPath) {
                        const updatedItem = {
                            ...item,
                            destinations: item.destinations.filter(d => d.path !== destPath)
                        };
                        if (mcActiveItem?.path === itemPath) setMcActiveItem(updatedItem);
                        return updatedItem;
                    }
                    return item;
                }));
            };
            
            // Copiar destinos de un item a todos los demás
            const mcCopyDestinationsToAll = (sourceItem) => {
                if (sourceItem.destinations.length === 0) {
                    setError('El item no tiene destinos');
                    return;
                }
                setMcSelectedItems(mcSelectedItems.map(item => ({
                    ...item,
                    destinations: [...sourceItem.destinations]
                })));
                setSuccess(`Destinos copiados a todos los items`);
            };
            
            // Generar vista previa
            const mcGeneratePreview = () => {
                const itemsWithDest = mcSelectedItems.filter(i => i.destinations.length > 0);
                if (itemsWithDest.length === 0) {
                    setError('Ningún item tiene destinos asignados');
                    return;
                }
                
                const totalOperations = itemsWithDest.reduce((sum, item) => sum + item.destinations.length, 0);
                
                const preview = {
                    items: itemsWithDest,
                    totalItems: itemsWithDest.length,
                    totalOperations: totalOperations
                };
                
                setMcPreview(preview);
                setMcShowPreview(true);
            };
            
            // Ejecutar multicopia - cada item a sus destinos específicos
            const executeNewMulticopy = async () => {
                const itemsWithDest = mcSelectedItems.filter(i => i.destinations.length > 0);
                if (itemsWithDest.length === 0) {
                    setError('Ningún item tiene destinos asignados');
                    return;
                }
                
                setProcessing(true);
                setMcShowPreview(false);
                
                let totalCopied = 0;
                let totalErrors = 0;
                
                try {
                    // Para cada item, copiar a cada uno de sus destinos
                    for (const item of itemsWithDest) {
                        for (const dest of item.destinations) {
                            const r = await fetch(`${API_BASE}/multicopy/execute`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    files: [item.path],
                                    dest_collection: dest.collection,
                                    full_dest_path: dest.path
                                })
                            });
                            const d = await r.json();
                            if (d.success) {
                                totalCopied += d.copied || 0;
                            } else {
                                totalErrors++;
                            }
                        }
                    }
                    
                    if (totalCopied > 0) {
                        setSuccess(`Copiados ${totalCopied} elementos`);
                    }
                    if (totalErrors > 0) {
                        setError(`${totalErrors} operación(es) con errores`);
                    }
                    
                    // Refrescar
                    loadMcDestContents(mcDestCollection, mcDestPath);
                    loadMcSourceContents(mcSourceCollection, mcSourcePath);
                    
                } catch (e) { setError(e.message); }
                finally { 
                    setProcessing(false); 
                    setMcPreview(null);
                }
            };
            
            // Borrar item en destino
            const mcDeleteInDest = async (itemPath, itemName, isFolder) => {
                if (!confirm(`¿Eliminar ${isFolder ? 'carpeta' : 'archivo'} "${itemName}" del destino?${isFolder ? '\n\n⚠️ Se borrará TODO el contenido.' : ''}`)) return;
                
                try {
                    if (isFolder) {
                        const r = await fetch(`${API_BASE}/folder/delete`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ full_path: itemPath, force: true })
                        });
                        const d = await r.json();
                        if (d.success) {
                            setSuccess(`Carpeta "${itemName}" eliminada`);
                            loadMcDestContents(mcDestCollection, mcDestPath);
                        } else {
                            setError(d.error);
                        }
                    } else {
                        const r = await fetch(`${API_BASE}/files/delete`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ files: [itemPath] })
                        });
                        const d = await r.json();
                        if (d.success_count > 0) {
                            setSuccess(`Archivo "${itemName}" eliminado`);
                            loadMcDestContents(mcDestCollection, mcDestPath);
                        }
                    }
                } catch (e) { setError(e.message); }
            };

            // Initial load for multicopy
            useEffect(() => {
                if (activeTab === 'multicopy') {
                    loadMcSourceContents(mcSourceCollection, mcSourcePath);
                    loadMcDestContents(mcDestCollection, mcDestPath);
                }
            }, [activeTab, mcSourceCollection, mcSourcePath, mcDestCollection, mcDestPath]);

            const selectFolderForRule = () => {
                const path = browserPath.join('/');
                const fullDest = `${browserCollection}:${path}`;
                if (!multicopyDestinations.includes(fullDest)) {
                    setMulticopyDestinations([...multicopyDestinations, fullDest]);
                }
                setShowFolderBrowser(false);
            };

            const selectFileForRule = (item) => {
                // Determine the full path based on the collection
                let filePath;
                if (fileBrowserCollection === 'TEMP') {
                    // For TEMP files, just use the filename (backend will resolve it)
                    filePath = item.name;
                } else {
                    // For FE/TS files, use the full_path from the item
                    filePath = item.full_path || item.name;
                }

                if (!multicopyFiles.includes(filePath)) {
                    setMulticopyFiles([...multicopyFiles, filePath]);
                }
                // Keep browser open to allow multiple selections
            };

            return (
                <div className="min-h-screen bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 text-white">
                    <header className="border-b border-purple-500/30 bg-black/30 px-3 py-1.5">
                        <div className="flex items-center justify-between">
                            <div className="flex items-center gap-2"><div className="w-7 h-7 bg-gradient-to-br from-cyan-400 to-purple-500 rounded flex items-center justify-center"><Icon name="terminal" className="w-4 h-4" /></div><span className="font-bold text-sm">ZX TOSEC Organizer</span></div>
                            <div className="flex items-center gap-3">
                                <div className="flex gap-2 text-xs">{feStructure && <span className="text-gray-400">FE: <span className="text-blue-400">{feStructure?.total_files?.toLocaleString()}</span></span>}{tsStructure && <span className="text-gray-400">TS: <span className="text-cyan-400">{tsStructure?.total_files?.toLocaleString()}</span></span>}</div>
                                <div className="flex gap-1">{['explorer', 'temp', 'multicopy', 'update', 'compress', 'nas'].map(tab => (<button key={tab} onClick={() => { setActiveTab(tab); if (tab === 'temp' || tab === 'update') loadTempFiles(); if (tab === 'nas') loadBackupFiles(); }} className={`px-2 py-1 rounded text-xs ${activeTab === tab ? 'bg-purple-600' : 'bg-gray-800 hover:bg-gray-700'}`}>{tab === 'explorer' ? 'Explorador' : tab === 'temp' ? 'TEMP' : tab === 'multicopy' ? 'Multicopia' : tab === 'update' ? 'Update' : tab === 'compress' ? 'Comprimir' : 'Backup NAS'}</button>))}</div>
                                <button onClick={() => setShowSearchModal(true)} className="px-3 py-1 bg-yellow-600 hover:bg-yellow-500 rounded text-xs flex items-center gap-1"><Icon name="search" className="w-3 h-3" />Buscar</button>
                            </div>
                        </div>
                    </header>

                    {/* Notificaciones flotantes - centradas en header */}
                    {(error || success) && (
                        <div className="fixed top-0.5 left-1/2 transform -translate-x-1/2 z-50 max-w-lg w-full px-4">
                            {error && <div className="px-6 py-1.5 bg-red-900/95 border border-red-500 rounded text-sm text-center shadow-lg backdrop-blur">{error}</div>}
                            {success && <div className="px-6 py-1.5 bg-green-900/95 border border-green-500 rounded text-sm text-center shadow-lg backdrop-blur">{success}</div>}
                        </div>
                    )}

                    <div className="p-2 h-[calc(100vh-50px)]">
                        {activeTab === 'explorer' && (
                            <div className="h-full flex gap-2">
                                <div className="w-96 h-full flex flex-col gap-2">
                                    {/* Panel FE en sidebar */}
                                    {feStructure && <div className="flex-1 bg-black/40 border border-blue-500/30 rounded p-2 overflow-hidden flex flex-col"><div className="flex items-center gap-1 mb-1 shrink-0"><Icon name="folder" className="w-3 h-3 text-blue-400" /><span className="text-xs font-bold text-blue-400">FE</span><span className="text-xs text-gray-400 ml-auto">{feStructure?.total_files?.toLocaleString()}</span></div><div className="flex-1 overflow-y-auto">{feStructure?.folders?.map((f, i) => (<button key={i} onClick={() => clickRootFE(f)} className={`w-full text-left px-1 py-0.5 rounded text-xs hover:bg-blue-500/20 flex justify-between ${fePath[0] === f.name ? 'bg-blue-500/30' : ''}`}><span className="truncate">{f.name}</span><span className="text-purple-400 ml-1">{f.file_count?.toLocaleString()}</span></button>))}</div></div>}
                                    {/* Panel TS en sidebar */}
                                    {tsStructure && <div className="flex-1 bg-black/40 border border-cyan-500/30 rounded p-2 overflow-hidden flex flex-col"><div className="flex items-center gap-1 mb-1 shrink-0"><Icon name="folder" className="w-3 h-3 text-cyan-400" /><span className="text-xs font-bold text-cyan-400">TS</span><span className="text-xs text-gray-400 ml-auto">{tsStructure?.total_files?.toLocaleString()}</span></div><div className="flex-1 overflow-y-auto">{tsStructure?.folders?.map((f, i) => (<button key={i} onClick={() => clickRootTS(f)} className={`w-full text-left px-1 py-0.5 rounded text-xs hover:bg-cyan-500/20 flex justify-between ${tsPath[0] === f.name ? 'bg-cyan-500/30' : ''}`}><span className="truncate">{f.name}</span><span className="text-purple-400 ml-1">{f.file_count?.toLocaleString()}</span></button>))}</div></div>}
                                    {/* Si no hay ninguna estructura */}
                                    {!feStructure && !tsStructure && <div className="flex-1 flex items-center justify-center text-gray-500 text-sm">No hay colecciones disponibles</div>}
                                </div>
                                <div className="flex-1 flex bg-black/40 border border-purple-500/20 rounded overflow-hidden">
                                    {/* Panel izquierdo */}
                                    <div className="flex-1 flex flex-col border-r border-purple-500/20" onDragOver={handleDragOver} onDragEnter={handleDragEnter} onDragLeave={handleDragLeave} onDrop={(e) => handleDrop(e, leftPanelCollection, leftPath)}>
                                        <div className={`px-2 py-1 ${leftPanelCollection === 'FE' ? 'bg-blue-900/30' : 'bg-cyan-900/30'} border-b border-purple-500/20 flex items-center gap-1 text-xs`}>
                                            <div className="flex gap-1 mr-2">
                                                {feStructure && <button onClick={() => switchLeftPanel('FE')} className={`px-2 py-0.5 rounded text-xs font-bold ${leftPanelCollection === 'FE' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-400 hover:bg-gray-600'}`}>FE</button>}
                                                {tsStructure && <button onClick={() => switchLeftPanel('TS')} className={`px-2 py-0.5 rounded text-xs font-bold ${leftPanelCollection === 'TS' ? 'bg-cyan-600 text-white' : 'bg-gray-700 text-gray-400 hover:bg-gray-600'}`}>TS</button>}
                                            </div>
                                            <button onClick={() => breadcrumbLeft(-1)} className={`font-bold ${leftPanelCollection === 'FE' ? 'text-blue-400' : 'text-cyan-400'} hover:underline`}>/</button>
                                            {leftPath.map((s, i) => (<React.Fragment key={i}><span className="text-gray-600">/</span><button onClick={() => breadcrumbLeft(i)} className="text-purple-400 truncate max-w-20 hover:underline">{s}</button></React.Fragment>))}
                                            {leftItems.length > 0 && <span className="text-yellow-400 font-bold">({leftItems.length})</span>}
                                            <div className="ml-auto flex gap-1">
                                                <button onClick={() => openNewFolderModal(leftPanelCollection)} className="p-0.5 hover:bg-gray-700 rounded" title="Nueva carpeta"><Icon name="plus" className="w-3 h-3 text-green-400" /></button>
                                                {leftSelected.length > 0 && <button onClick={deleteLeftSelected} className="p-0.5 hover:bg-red-700 rounded bg-red-600" title={`Borrar ${leftSelected.length} archivo(s)`}><Icon name="trash" className="w-3 h-3" /></button>}
                                                <button onClick={refreshLeft} className="p-0.5 hover:bg-gray-700 rounded"><Icon name="refresh" className="w-3 h-3 text-gray-400" /></button>
                                            </div>
                                        </div>
                                        <div className="flex-1 overflow-y-auto p-1">
                                            {leftLoading ? <div className="flex items-center justify-center h-full"><Icon name="loader" className={`w-5 h-5 ${leftPanelCollection === 'FE' ? 'text-blue-400' : 'text-cyan-400'}`} /></div> : 
                                            <div className="space-y-0.5">{leftItems.map((item, idx) => <FileRow key={idx} item={item} collection={leftPanelCollection} onFolderClick={clickFolderLeft} isSelected={leftSelected.includes(item.full_path)} onToggleSelect={(col, path) => toggleLeftSelection(path)} onDeleteFolder={deleteFolder} onRename={renameFile} />)}</div>}
                                        </div>
                                        {leftSelected.length > 0 && <div className="px-2 py-1 bg-purple-900/30 border-t border-purple-500/20 text-xs text-purple-300">{leftSelected.length} archivo(s) seleccionado(s)</div>}
                                    </div>
                                    {/* Panel derecho */}
                                    <div className="flex-1 flex flex-col" onDragOver={handleDragOver} onDragEnter={handleDragEnter} onDragLeave={handleDragLeave} onDrop={(e) => handleDrop(e, rightPanelCollection, rightPath)}>
                                        <div className={`px-2 py-1 ${rightPanelCollection === 'FE' ? 'bg-blue-900/30' : 'bg-cyan-900/30'} border-b border-purple-500/20 flex items-center gap-1 text-xs`}>
                                            <div className="flex gap-1 mr-2">
                                                {feStructure && <button onClick={() => switchRightPanel('FE')} className={`px-2 py-0.5 rounded text-xs font-bold ${rightPanelCollection === 'FE' ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-400 hover:bg-gray-600'}`}>FE</button>}
                                                {tsStructure && <button onClick={() => switchRightPanel('TS')} className={`px-2 py-0.5 rounded text-xs font-bold ${rightPanelCollection === 'TS' ? 'bg-cyan-600 text-white' : 'bg-gray-700 text-gray-400 hover:bg-gray-600'}`}>TS</button>}
                                            </div>
                                            <button onClick={() => breadcrumbRight(-1)} className={`font-bold ${rightPanelCollection === 'FE' ? 'text-blue-400' : 'text-cyan-400'} hover:underline`}>/</button>
                                            {rightPath.map((s, i) => (<React.Fragment key={i}><span className="text-gray-600">/</span><button onClick={() => breadcrumbRight(i)} className="text-purple-400 truncate max-w-20 hover:underline">{s}</button></React.Fragment>))}
                                            {rightItems.length > 0 && <span className="text-yellow-400 font-bold">({rightItems.length})</span>}
                                            <div className="ml-auto flex gap-1">
                                                <button onClick={() => openNewFolderModal(rightPanelCollection)} className="p-0.5 hover:bg-gray-700 rounded" title="Nueva carpeta"><Icon name="plus" className="w-3 h-3 text-green-400" /></button>
                                                {rightSelected.length > 0 && <button onClick={deleteRightSelected} className="p-0.5 hover:bg-red-700 rounded bg-red-600" title={`Borrar ${rightSelected.length} archivo(s)`}><Icon name="trash" className="w-3 h-3" /></button>}
                                                <button onClick={refreshRight} className="p-0.5 hover:bg-gray-700 rounded"><Icon name="refresh" className="w-3 h-3 text-gray-400" /></button>
                                            </div>
                                        </div>
                                        <div className="flex-1 overflow-y-auto p-1">
                                            {rightLoading ? <div className="flex items-center justify-center h-full"><Icon name="loader" className={`w-5 h-5 ${rightPanelCollection === 'FE' ? 'text-blue-400' : 'text-cyan-400'}`} /></div> : 
                                            <div className="space-y-0.5">{rightItems.map((item, idx) => <FileRow key={idx} item={item} collection={rightPanelCollection} onFolderClick={clickFolderRight} isSelected={rightSelected.includes(item.full_path)} onToggleSelect={(col, path) => toggleRightSelection(path)} onDeleteFolder={deleteFolder} onRename={renameFile} />)}</div>}
                                        </div>
                                        {rightSelected.length > 0 && <div className="px-2 py-1 bg-purple-900/30 border-t border-purple-500/20 text-xs text-purple-300">{rightSelected.length} archivo(s) seleccionado(s)</div>}
                                    </div>
                                </div>
                            </div>
                        )}

                        {activeTab === 'temp' && (<div className="h-full flex flex-col overflow-hidden bg-black/30 border border-purple-500/30 rounded p-3">
                            <h2 className="font-bold flex items-center gap-2 mb-4"><Icon name="zap" className="w-5 h-5 text-yellow-400" />Copiar TEMP a Colección</h2>
                            <p className="text-sm text-gray-400 mb-4">Copia los archivos de TEMP directamente a <code className="bg-gray-800 px-1 rounded">FE</code> o <code className="bg-gray-800 px-1 rounded">TS</code></p>
                            <div className="flex-1 flex flex-col min-h-0 space-y-4">
                                <div className="flex items-center gap-2">
                                    <button onClick={() => { setTempTargetCollection('FE'); setTempPreview(null); }} className={`px-4 py-2 rounded font-bold ${tempTargetCollection === 'FE' ? 'bg-blue-600' : 'bg-gray-700'}`}>FE</button>
                                    <button onClick={() => { setTempTargetCollection('TS'); setTempPreview(null); }} className={`px-4 py-2 rounded font-bold ${tempTargetCollection === 'TS' ? 'bg-cyan-600' : 'bg-gray-700'}`}>TS</button>
                                    <button onClick={previewTempCopy} disabled={tempStatus.running || tempFiles.length === 0} className={`px-4 py-2 rounded font-bold flex items-center gap-2 ${tempFiles.length === 0 ? 'bg-gray-600 cursor-not-allowed' : 'bg-yellow-600 hover:bg-yellow-500'}`}>🔍 Ver destinos</button>
                                    <button onClick={executeTempCopy} disabled={tempStatus.running || tempFiles.length === 0} className={`px-4 py-2 rounded font-bold flex items-center gap-2 ${tempStatus.running || tempFiles.length === 0 ? 'bg-gray-600 cursor-not-allowed' : 'bg-green-600 hover:bg-green-500'}`}>{tempStatus.running ? <><Icon name="loader" className="w-4 h-4 animate-spin" />Copiando...</> : <>📦 Copiar a {tempTargetCollection}</>}</button>
                                </div>
                                
                                {tempStatus.error && <div className="p-2 bg-red-900/30 border border-red-500 rounded text-sm text-red-400">{tempStatus.error}</div>}
                                
                                {/* Vista previa de destinos */}
                                {tempPreview && tempPreview.length > 0 && !tempStatus.done && (
                                    <div className="flex-1 min-h-0 flex flex-col mt-4 p-3 bg-yellow-900/20 border border-yellow-500/30 rounded">
                                        <h3 className="font-bold text-sm mb-2 text-yellow-400">🔍 Vista previa de destinos para {tempTargetCollection}</h3>
                                        <div className="flex-1 overflow-y-auto space-y-2">{tempPreview.map((f, i) => (
                                            <div key={i} className={`p-2 rounded text-xs ${f.has_destinations ? 'bg-gray-800/50 border border-gray-700' : 'bg-red-900/20 border border-red-700/30'}`}>
                                                <p className="font-medium text-white">{f.filename}</p>
                                                {f.tosec_info && <p className="text-gray-500 text-xs">Título: {f.tosec_info.title} | Año: {f.tosec_info.year || '?'}</p>}
                                                {f.dest_paths && f.dest_paths.length > 0 ? (
                                                    <div className="mt-1 text-green-400">{f.dest_paths.map((p, j) => <p key={j} className="truncate">→ {p}</p>)}</div>
                                                ) : (
                                                    <p className="text-red-400 mt-1">{f.error || 'Sin destinos disponibles'}</p>
                                                )}
                                            </div>
                                        ))}</div>
                                    </div>
                                )}
                                
                                {/* Resultados de copia */}
                                {tempStatus.done && tempResults.length > 0 && (
                                    <div className="flex-1 min-h-0 flex flex-col mt-4">
                                        <h3 className="font-bold text-sm mb-2 text-green-400">✓ Archivos copiados ({tempResults.filter(r => r.success).length}/{tempResults.length})</h3>
                                        <div className="flex-1 overflow-y-auto space-y-1">{tempResults.map((r, i) => (
                                            <div key={i} className={`p-2 rounded text-xs ${r.success ? 'bg-green-900/20 border border-green-700/30' : 'bg-red-900/20 border border-red-700/30'}`}>
                                                <p className="font-medium truncate">{r.filename}</p>
                                                {r.dest_paths && r.dest_paths.length > 0 && r.dest_paths.map((p, j) => <p key={j} className="text-gray-400 truncate">→ {p}</p>)}
                                                {r.error && <p className="text-red-400">{r.error}</p>}
                                            </div>
                                        ))}</div>
                                    </div>
                                )}
                                
                                {/* Archivos en TEMP */}
                                <div className="flex-1 min-h-0 flex flex-col p-3 bg-gray-800/50 rounded border border-gray-700">
                                    <div className="flex justify-between items-center mb-2 shrink-0">
                                        <h4 className="font-bold text-sm text-yellow-400">📁 Archivos en TEMP ({tempFiles.length})</h4>
                                        <div className="flex gap-1">
                                            <button onClick={loadTempFiles} className="px-2 py-1 bg-purple-600 rounded text-xs" title="Refrescar"><Icon name="refresh" className="w-3 h-3" /></button>
                                        </div>
                                    </div>
                                    {tempFiles.length === 0 ? <p className="text-gray-500 text-sm text-center py-8">No hay archivos en TEMP</p> :
                                    <div className="flex-1 overflow-y-auto space-y-1">{tempFiles.map((f, i) => (
                                        <div key={i} className="flex items-center gap-2 py-1 px-2 hover:bg-gray-700/50 rounded group bg-gray-900/30">
                                            <Icon name="file" className={`w-4 h-4 ${isEmulable(f.name) ? 'text-green-400' : 'text-cyan-400'}`} />
                                            <span className="truncate flex-1 text-gray-200 text-sm">{f.name}</span>
                                            <span className="text-gray-500 text-xs">{(f.size / 1024).toFixed(1)}KB</span>
                                            <div className="flex gap-1 opacity-50 group-hover:opacity-100">
                                                {isEmulable(f.name) && <button onClick={() => loadInEmulator(f.full_path, f.name)} className="px-2 py-1 bg-green-600 hover:bg-green-500 rounded text-xs" title="Emular"><Icon name="play" className="w-3 h-3" /></button>}
                                                <button onClick={() => renameTempFile(f.full_path, f.name)} className="px-2 py-1 bg-blue-600 hover:bg-blue-500 rounded text-xs" title="Renombrar"><Icon name="edit" className="w-3 h-3" /></button>
                                                <button onClick={() => deleteTempFile(f.name)} className="px-2 py-1 bg-red-600 hover:bg-red-500 rounded text-xs" title="Eliminar"><Icon name="trash" className="w-3 h-3" /></button>
                                            </div>
                                        </div>
                                    ))}</div>}
                                </div>
                            </div>
                        </div>)}

                        {activeTab === 'update' && (<div className="h-full flex flex-col overflow-hidden bg-black/30 border border-purple-500/30 rounded p-3">
                            <h2 className="font-bold flex items-center gap-2 mb-4"><Icon name="upload" className="w-5 h-5 text-green-400" />Copiar a UPDATES_TOSEC</h2>
                            <p className="text-sm text-gray-400 mb-4">Copia los archivos de TEMP a la estructura vacía en <code className="bg-gray-800 px-1 rounded">C:\ZX\UPDATES_TOSEC</code></p>
                            <div className="flex-1 flex flex-col min-h-0 space-y-4">
                                <div className="flex items-center gap-2">
                                    <button onClick={() => { setUpdateTargetCollection('FE'); setUpdatePreview(null); }} className={`px-4 py-2 rounded font-bold ${updateTargetCollection === 'FE' ? 'bg-blue-600' : 'bg-gray-700'}`}>FE</button>
                                    <button onClick={() => { setUpdateTargetCollection('TS'); setUpdatePreview(null); }} className={`px-4 py-2 rounded font-bold ${updateTargetCollection === 'TS' ? 'bg-cyan-600' : 'bg-gray-700'}`}>TS</button>
                                    <button onClick={previewUpdatePackage} disabled={updateStatus.running || tempFiles.length === 0} className={`px-4 py-2 rounded font-bold flex items-center gap-2 ${tempFiles.length === 0 ? 'bg-gray-600 cursor-not-allowed' : 'bg-yellow-600 hover:bg-yellow-500'}`}>🔍 Ver destinos</button>
                                    <button onClick={generateUpdatePackage} disabled={updateStatus.running || tempFiles.length === 0} className={`px-4 py-2 rounded font-bold flex items-center gap-2 ${updateStatus.running || tempFiles.length === 0 ? 'bg-gray-600 cursor-not-allowed' : 'bg-green-600 hover:bg-green-500'}`}>{updateStatus.running ? <><Icon name="loader" className="w-4 h-4 animate-spin" />Copiando...</> : <>📦 Copiar a {updateTargetCollection}</>}</button>
                                    <button onClick={loadTempFiles} className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded" title="Refrescar"><Icon name="refresh" className="w-4 h-4" /></button>
                                </div>
                                
                                {updateStatus.error && <div className="p-2 bg-red-900/30 border border-red-500 rounded text-sm text-red-400">{updateStatus.error}</div>}
                                
                                {/* Vista previa de destinos */}
                                {updatePreview && updatePreview.length > 0 && !updateStatus.done && (
                                    <div className="flex-1 min-h-0 flex flex-col mt-4 p-3 bg-yellow-900/20 border border-yellow-500/30 rounded">
                                        <h3 className="font-bold text-sm mb-2 text-yellow-400">🔍 Vista previa de destinos para {updateTargetCollection}</h3>
                                        <div className="flex-1 overflow-y-auto space-y-2">{updatePreview.map((f, i) => (
                                            <div key={i} className={`p-2 rounded text-xs ${f.has_destinations ? 'bg-gray-800/50 border border-gray-700' : 'bg-red-900/20 border border-red-700/30'}`}>
                                                <p className="font-medium text-white">{f.filename}</p>
                                                {f.tosec_info && <p className="text-gray-500 text-xs">Título: {f.tosec_info.title} | Año: {f.tosec_info.year || '?'}</p>}
                                                {f.dest_paths && f.dest_paths.length > 0 ? (
                                                    <div className="mt-1 text-green-400">{f.dest_paths.map((p, j) => <p key={j} className="truncate">→ {p}</p>)}</div>
                                                ) : (
                                                    <p className="text-red-400 mt-1">{f.error || 'Sin destinos disponibles'}</p>
                                                )}
                                            </div>
                                        ))}</div>
                                    </div>
                                )}
                                
                                {/* Resultados de copia */}
                                {updateStatus.done && updateResults.length > 0 && (
                                    <div className="flex-1 min-h-0 flex flex-col mt-4">
                                        <h3 className="font-bold text-sm mb-2 text-green-400">✓ Archivos copiados ({updateResults.filter(r => r.success).length}/{updateResults.length})</h3>
                                        <div className="flex-1 overflow-y-auto space-y-1">{updateResults.map((r, i) => (
                                            <div key={i} className={`p-2 rounded text-xs ${r.success ? 'bg-green-900/20 border border-green-700/30' : 'bg-red-900/20 border border-red-700/30'}`}>
                                                <p className="font-medium truncate">{r.filename}</p>
                                                {r.dest_paths && r.dest_paths.length > 0 && r.dest_paths.map((p, j) => <p key={j} className="text-gray-400 truncate">→ {p}</p>)}
                                                {r.error && <p className="text-red-400">{r.error}</p>}
                                            </div>
                                        ))}</div>
                                    </div>
                                )}
                                
                                {/* Archivos en TEMP */}
                                <div className="mt-4 p-3 bg-gray-800/50 rounded border border-gray-700">
                                    <h4 className="font-bold text-xs text-purple-400 mb-2">📁 Archivos en TEMP ({tempFiles.length})</h4>
                                    {tempFiles.length === 0 ? <p className="text-gray-500 text-xs">No hay archivos en TEMP</p> :
                                    <div className="max-h-64 overflow-y-auto text-xs space-y-0.5">{tempFiles.map((f, i) => (<div key={i} className="truncate text-gray-300 py-0.5 px-1 hover:bg-gray-700/50 rounded">{f.name}</div>))}</div>}
                                </div>
                            </div>
                        </div>)}
                        
                        {activeTab === 'compress' && (<div className="h-full overflow-auto bg-black/30 border border-purple-500/30 rounded p-3"><h2 className="font-bold flex items-center gap-2 mb-4"><Icon name="archive" className="w-5 h-5 text-orange-400" />Comprimir TOSEC</h2><div className="space-y-4 max-w-xl"><div><label className="block text-sm mb-1">Colección</label><div className="flex gap-2"><button onClick={() => setCompressCollection('FE')} className={`px-4 py-2 rounded ${compressCollection === 'FE' ? 'bg-blue-600' : 'bg-gray-700'}`}>FE</button><button onClick={() => setCompressCollection('TS')} className={`px-4 py-2 rounded ${compressCollection === 'TS' ? 'bg-cyan-600' : 'bg-gray-700'}`}>TS</button></div></div><div><label className="block text-sm mb-1">Destino</label><input type="text" value={compressDestPath} onChange={(e) => setCompressDestPath(e.target.value)} className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded" /></div><div><label className="block text-sm mb-1">Tamaño volumen</label><div className="flex gap-2"><button onClick={() => setCompressVolumeSize(1950)} className={`px-4 py-2 rounded ${compressVolumeSize === 1950 ? 'bg-purple-600' : 'bg-gray-700'}`}>~2 GB</button><button onClick={() => setCompressVolumeSize(3900)} className={`px-4 py-2 rounded ${compressVolumeSize === 3900 ? 'bg-purple-600' : 'bg-gray-700'}`}>~4 GB</button></div></div><div><label className="block text-sm mb-1">Formato</label><div className="flex gap-2">{['zip', '7z'].map(f => (<button key={f} onClick={() => setCompressFormat(f)} className={`px-3 py-1 rounded ${compressFormat === f ? 'bg-purple-600' : 'bg-gray-700'}`}>{f.toUpperCase()}</button>))}</div></div>
                            {compressProgress && (<div className="p-3 bg-gray-800/50 rounded border border-gray-700"><div className="text-sm mb-2 text-gray-300">{compressProgress.progress}</div><div className="w-full bg-gray-700 rounded-full h-5 overflow-hidden"><div className="bg-gradient-to-r from-purple-500 to-cyan-500 h-5 rounded-full transition-all duration-300 flex items-center justify-center" style={{ width: `${compressProgress.percent}%` }}><span className="text-xs text-white font-bold drop-shadow">{compressProgress.percent}%</span></div></div></div>)}
                            <div className="flex gap-2">
                                <button onClick={startCompression} disabled={compressing} className={`px-4 py-2 rounded flex items-center gap-2 ${compressing ? 'bg-gray-600' : 'bg-orange-600 hover:bg-orange-500'}`}>{compressing ? <Icon name="loader" className="w-4 h-4 animate-spin" /> : <Icon name="archive" className="w-4 h-4" />}{compressing ? 'Comprimiendo...' : 'Comprimir'}</button>
                                {compressing && <button onClick={cancelCompression} className="px-4 py-2 rounded flex items-center gap-2 bg-red-600 hover:bg-red-500"><Icon name="x" className="w-4 h-4" />Cancelar</button>}
                            </div></div></div>)}


                        {activeTab === 'multicopy' && (
                            <div className="h-full flex flex-col bg-black/30 border border-purple-500/30 rounded p-3 overflow-hidden">
                                <h2 className="font-bold mb-3 flex items-center gap-2 shrink-0"><Icon name="copy" className="w-4 h-4 text-blue-400" />Multicopia v3 - Múltiples Orígenes y Destinos</h2>
                                <div className="flex-1 flex gap-3 overflow-hidden min-h-0">
                                    {/* Panel ORIGEN */}
                                    <div className="w-1/3 flex flex-col bg-gray-800/30 rounded border border-blue-500/30 overflow-hidden">
                                        <div className="p-2 bg-blue-900/30 border-b border-blue-500/30 flex justify-between items-center shrink-0">
                                            <span className="text-xs font-bold text-blue-400">📂 ORIGEN</span>
                                            <div className="flex gap-1">
                                                {['TEMP', 'FE', 'TS'].map(c => (
                                                    <button key={c} onClick={() => { setMcSourceCollection(c); setMcSourcePath([]); }} className={`px-2 py-0.5 rounded text-xs font-bold ${mcSourceCollection === c ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-400 hover:bg-gray-600'}`}>{c}</button>
                                                ))}
                                            </div>
                                        </div>
                                        <div className="px-2 py-1 bg-gray-800/50 border-b border-gray-700 flex items-center gap-1 text-xs overflow-x-auto whitespace-nowrap shrink-0">
                                            <button onClick={() => setMcSourcePath([])} className="text-blue-400 font-bold hover:underline">/</button>
                                            {mcSourcePath.map((p, i) => (
                                                <React.Fragment key={i}>
                                                    <span className="text-gray-600">/</span>
                                                    <button onClick={() => setMcSourcePath(mcSourcePath.slice(0, i + 1))} className="text-gray-300 hover:text-white truncate max-w-[80px]">{p.split(/[/\\]/).pop()}</button>
                                                </React.Fragment>
                                            ))}
                                            <span className="ml-auto text-gray-500">({mcSourceItems.length})</span>
                                        </div>
                                        <div className="flex-1 overflow-y-auto p-1 space-y-0.5">
                                            {mcLoading ? <div className="flex justify-center p-4"><Icon name="loader" className="w-5 h-5 text-blue-400" /></div> :
                                                mcSourceItems.map((item, i) => {
                                                    const isSelected = mcSelectedItems.find(s => s.path === item.full_path);
                                                    return (
                                                        <div key={i} className={`p-1.5 rounded text-xs flex items-center gap-2 group cursor-pointer ${isSelected ? 'bg-blue-600/40 border border-blue-500' : 'hover:bg-gray-700/50 border border-transparent'}`}>
                                                            <div className="flex-1 flex items-center gap-2 min-w-0" onClick={() => item.type === 'folder' ? setMcSourcePath([...mcSourcePath, item.full_path]) : null}>
                                                                <Icon name={item.type === 'folder' ? 'folder' : 'file'} className={`w-3.5 h-3.5 shrink-0 ${item.type === 'folder' ? 'text-yellow-400' : 'text-gray-400'}`} />
                                                                <span className="truncate">{item.name}</span>
                                                            </div>
                                                            {item.type === 'file' && <span className="text-gray-500 text-xs shrink-0">{(item.size/1024).toFixed(0)}K</span>}
                                                            <button onClick={(e) => { e.stopPropagation(); isSelected ? mcRemoveFromSelection(item.full_path) : mcAddToSelection(item); }} className={`p-1 rounded shrink-0 ${isSelected ? 'bg-red-600 hover:bg-red-500' : 'bg-green-600 hover:bg-green-500'}`} title={isSelected ? 'Quitar' : 'Añadir'}>
                                                                <span className="text-xs">{isSelected ? '−' : '+'}</span>
                                                            </button>
                                                        </div>
                                                    );
                                                })}
                                        </div>
                                    </div>

                                    {/* Panel SELECCIÓN (centro) - Items con sus destinos */}
                                    <div className="w-1/3 flex flex-col bg-gray-800/30 rounded border border-yellow-500/30 overflow-hidden">
                                        <div className="p-2 bg-yellow-900/30 border-b border-yellow-500/30 flex justify-between items-center shrink-0">
                                            <span className="text-xs font-bold text-yellow-400">📋 ITEMS Y DESTINOS ({mcSelectedItems.length})</span>
                                            {mcSelectedItems.length > 0 && <button onClick={() => { setMcSelectedItems([]); setMcActiveItem(null); }} className="text-xs text-red-400 hover:text-red-300">Limpiar todo</button>}
                                        </div>
                                        <div className="flex-1 overflow-y-auto p-1 space-y-1">
                                            {mcSelectedItems.length === 0 ? (
                                                <div className="text-center text-gray-600 text-xs py-4">
                                                    <p>1. Añade archivos/carpetas del panel izquierdo</p>
                                                    <p className="mt-1">2. Selecciona cada item y añade destinos</p>
                                                </div>
                                            ) : mcSelectedItems.map((item, i) => (
                                                <div key={i} className={`rounded border ${mcActiveItem?.path === item.path ? 'border-yellow-500 bg-yellow-900/20' : 'border-gray-700 bg-gray-800/50'}`}>
                                                    {/* Cabecera del item */}
                                                    <div className="p-1.5 flex items-center gap-2 cursor-pointer" onClick={() => mcSetActiveItem(item)}>
                                                        <button onClick={(e) => { e.stopPropagation(); mcToggleExpand(item.path); }} className="text-gray-400 hover:text-white text-xs w-4">
                                                            {mcExpandedItems.includes(item.path) ? '▼' : '▶'}
                                                        </button>
                                                        <Icon name={item.type === 'folder' ? 'folder' : 'file'} className={`w-3 h-3 shrink-0 ${item.type === 'folder' ? 'text-yellow-400' : 'text-gray-400'}`} />
                                                        <span className="truncate flex-1 text-xs" title={item.path}>{item.name}</span>
                                                        <span className={`text-xs px-1.5 py-0.5 rounded ${item.destinations.length > 0 ? 'bg-green-600' : 'bg-gray-600'}`}>
                                                            {item.destinations.length}
                                                        </span>
                                                        <button onClick={(e) => { e.stopPropagation(); mcRemoveFromSelection(item.path); }} className="text-red-500 hover:text-red-400 text-xs">✕</button>
                                                    </div>
                                                    {/* Destinos del item (expandible) */}
                                                    {mcExpandedItems.includes(item.path) && (
                                                        <div className="px-2 pb-2 space-y-1 border-t border-gray-700/50 mt-1 pt-1">
                                                            {item.destinations.length === 0 ? (
                                                                <div className="text-xs text-gray-500 italic">Sin destinos asignados</div>
                                                            ) : item.destinations.map((dest, j) => (
                                                                <div key={j} className="flex items-center gap-1 text-xs bg-gray-900/50 rounded px-1.5 py-1 group">
                                                                    <span className={`px-1 py-0.5 rounded text-xs font-bold ${dest.collection === 'FE' ? 'bg-blue-600' : dest.collection === 'TS' ? 'bg-cyan-600' : 'bg-purple-600'}`}>{dest.collection}</span>
                                                                    <span className="truncate flex-1 text-gray-400" title={dest.path}>{dest.pathDisplay}</span>
                                                                    <button onClick={() => mcRemoveDestinationFromItem(item.path, dest.path)} className="text-red-500 hover:text-red-400 opacity-0 group-hover:opacity-100">✕</button>
                                                                </div>
                                                            ))}
                                                            {item.destinations.length > 0 && (
                                                                <button onClick={() => mcCopyDestinationsToAll(item)} className="text-xs text-cyan-400 hover:text-cyan-300 mt-1">
                                                                    📋 Copiar destinos a todos
                                                                </button>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                        {/* Info del item activo */}
                                        {mcActiveItem && (
                                            <div className="p-2 bg-yellow-900/40 border-t border-yellow-500/30 shrink-0">
                                                <div className="text-xs text-yellow-300">
                                                    <strong>Activo:</strong> {mcActiveItem.name}
                                                </div>
                                                <div className="text-xs text-gray-400 mt-0.5">
                                                    Navega a la derecha y pulsa "Añadir destino"
                                                </div>
                                            </div>
                                        )}
                                        {/* Botones de acción */}
                                        <div className="flex gap-2 p-2 border-t border-gray-700 shrink-0">
                                            <button onClick={mcGeneratePreview} disabled={mcSelectedItems.filter(i => i.destinations.length > 0).length === 0} className={`flex-1 px-3 py-2 rounded font-bold text-sm flex items-center justify-center gap-2 ${mcSelectedItems.filter(i => i.destinations.length > 0).length > 0 ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`}>
                                                🔍 Preview
                                            </button>
                                            <button onClick={executeNewMulticopy} disabled={mcSelectedItems.filter(i => i.destinations.length > 0).length === 0 || processing} className={`flex-1 px-3 py-2 rounded font-bold text-sm flex items-center justify-center gap-2 ${mcSelectedItems.filter(i => i.destinations.length > 0).length > 0 && !processing ? 'bg-green-600 hover:bg-green-500' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`}>
                                                {processing ? <Icon name="loader" className="w-4 h-4" /> : '📦'} Copiar
                                            </button>
                                        </div>
                                    </div>

                                    {/* Panel DESTINO */}
                                    <div className="w-1/3 flex flex-col bg-gray-800/30 rounded border border-cyan-500/30 overflow-hidden">
                                        <div className="p-2 bg-cyan-900/30 border-b border-cyan-500/30 flex justify-between items-center shrink-0">
                                            <span className="text-xs font-bold text-cyan-400">📁 DESTINO</span>
                                            <div className="flex gap-1">
                                                {['FE', 'TS', 'UPD'].map(c => (
                                                    <button key={c} onClick={() => { setMcDestCollection(c); setMcDestPath([]); }} className={`px-2 py-0.5 rounded text-xs font-bold ${mcDestCollection === c ? 'bg-cyan-600 text-white' : 'bg-gray-700 text-gray-400 hover:bg-gray-600'}`}>{c === 'UPD' ? 'UPD' : c}</button>
                                                ))}
                                            </div>
                                        </div>
                                        <div className="px-2 py-1 bg-gray-800/50 border-b border-gray-700 flex items-center gap-1 text-xs overflow-x-auto whitespace-nowrap shrink-0">
                                            <button onClick={() => setMcDestPath([])} className="text-cyan-400 font-bold hover:underline">/</button>
                                            {mcDestPath.map((p, i) => (
                                                <React.Fragment key={i}>
                                                    <span className="text-gray-600">/</span>
                                                    <button onClick={() => setMcDestPath(mcDestPath.slice(0, i + 1))} className="text-gray-300 hover:text-white truncate max-w-[80px]">{p.split(/[/\\]/).pop()}</button>
                                                </React.Fragment>
                                            ))}
                                            <span className="ml-auto text-gray-500">({mcDestItems.length})</span>
                                        </div>
                                        <div className="flex-1 overflow-y-auto p-1 space-y-0.5">
                                            {mcLoading ? <div className="flex justify-center p-4"><Icon name="loader" className="w-5 h-5 text-cyan-400" /></div> :
                                                mcDestItems.map((item, i) => (
                                                    <div key={i} className="p-1.5 rounded text-xs flex items-center gap-2 group hover:bg-gray-700/50">
                                                        <div className="flex-1 flex items-center gap-2 min-w-0 cursor-pointer" onClick={() => item.type === 'folder' && setMcDestPath([...mcDestPath, item.full_path])}>
                                                            <Icon name={item.type === 'folder' ? 'folder' : 'file'} className={`w-3.5 h-3.5 shrink-0 ${item.type === 'folder' ? 'text-cyan-400' : 'text-gray-500'}`} />
                                                            <span className="truncate">{item.name}</span>
                                                        </div>
                                                        <button onClick={(e) => { e.stopPropagation(); mcDeleteInDest(item.full_path, item.name, item.type === 'folder'); }} className="p-1 bg-red-600/50 hover:bg-red-500 rounded opacity-0 group-hover:opacity-100" title="Eliminar"><Icon name="trash" className="w-2.5 h-2.5" /></button>
                                                    </div>
                                                ))}
                                        </div>
                                        <div className="p-2 bg-gray-900/50 border-t border-gray-700 shrink-0">
                                            <button onClick={mcAddDestinationToItem} disabled={!mcActiveItem} className={`w-full px-3 py-2 rounded font-bold text-sm flex items-center justify-center gap-2 ${mcActiveItem ? 'bg-cyan-600 hover:bg-cyan-500' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`}>
                                                ➕ Añadir destino {mcActiveItem ? `a "${mcActiveItem.name.substring(0,15)}${mcActiveItem.name.length > 15 ? '...' : ''}"` : '(selecciona item)'}
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                {/* Modal de vista previa */}
                                {mcShowPreview && mcPreview && (
                                    <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                                        <div className="bg-gray-900 border border-purple-500/50 rounded-lg p-4 max-w-3xl w-full max-h-[80vh] overflow-auto">
                                            <h3 className="font-bold text-lg mb-4 flex items-center gap-2"><Icon name="search" className="w-5 h-5 text-yellow-400" />Vista previa de copia</h3>
                                            <div className="space-y-3">
                                                {mcPreview.items.map((item, i) => (
                                                    <div key={i} className="bg-gray-800/50 rounded p-3">
                                                        <div className="flex items-center gap-2 mb-2">
                                                            <Icon name={item.type === 'folder' ? 'folder' : 'file'} className={`w-4 h-4 ${item.type === 'folder' ? 'text-yellow-400' : 'text-gray-400'}`} />
                                                            <span className="font-bold text-sm">{item.name}</span>
                                                            <span className="text-gray-500 text-xs">→ {item.destinations.length} destino(s)</span>
                                                        </div>
                                                        <div className="pl-6 space-y-1">
                                                            {item.destinations.map((dest, j) => (
                                                                <div key={j} className="text-xs flex items-center gap-2 text-gray-300">
                                                                    <span className={`px-1.5 py-0.5 rounded font-bold ${dest.collection === 'FE' ? 'bg-blue-600' : dest.collection === 'TS' ? 'bg-cyan-600' : 'bg-purple-600'}`}>{dest.collection}</span>
                                                                    <span className="truncate">{dest.pathDisplay}</span>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    </div>
                                                ))}
                                                <div className="bg-yellow-900/30 border border-yellow-500/30 rounded p-3 text-sm">
                                                    <strong>Total:</strong> {mcPreview.totalItems} items → {mcPreview.totalOperations} operaciones de copia
                                                </div>
                                            </div>
                                            <div className="flex justify-end gap-2 mt-4">
                                                <button onClick={() => setMcShowPreview(false)} className="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded">Cancelar</button>
                                                <button onClick={executeNewMulticopy} className="px-4 py-2 bg-green-600 hover:bg-green-500 rounded font-bold flex items-center gap-2">
                                                    <Icon name="copy" className="w-4 h-4" /> Ejecutar copia
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {activeTab === 'nas' && (<div className="h-full flex flex-col overflow-hidden bg-black/30 border border-purple-500/30 rounded p-3">
                            <h2 className="font-bold flex items-center gap-2 mb-4 shrink-0"><Icon name="server" className="w-5 h-5 text-blue-400" />Backup NAS - revisteo.synology.me</h2>
                            <div className="flex-1 grid grid-cols-2 gap-4 min-h-0">
                            {/* Archivos locales */}
                            <div className="flex flex-col bg-gray-800/50 border border-gray-700 rounded p-3 min-h-0">
                                <div className="flex justify-between items-center mb-2 shrink-0">
                                    <h3 className="font-semibold text-sm">C:\ZX\Backups\</h3>
                                    <div className="flex gap-1">
                                        <button onClick={loadBackupFiles} className="px-2 py-1 bg-gray-700 rounded text-xs">🔄</button>
                                        <button onClick={selectAllBackupFiles} className="px-2 py-1 bg-purple-600 rounded text-xs">Todos</button>
                                        <button onClick={deselectAllBackupFiles} className="px-2 py-1 bg-gray-600 rounded text-xs">Ninguno</button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto space-y-1">
                                    {backupFiles.length === 0 ? <p className="text-gray-500 text-sm text-center py-4">Sin archivos</p> : backupFiles.map((f, i) => (
                                        <label key={i} className="flex items-center gap-2 p-2 bg-gray-900/50 rounded cursor-pointer hover:bg-gray-700/50">
                                            <input type="checkbox" checked={selectedBackupFiles.includes(f.name)} onChange={() => toggleBackupFile(f.name)} />
                                            <Icon name="archive" className="w-4 h-4 text-orange-400" />
                                            <span className="flex-1 truncate text-sm">{f.name}</span>
                                            <span className="text-xs text-gray-400">{formatSize(f.size)}</span>
                                        </label>
                                    ))}
                                </div>
                                {selectedBackupFiles.length > 0 && <p className="mt-2 text-sm text-yellow-400 shrink-0">{selectedBackupFiles.length} seleccionados ({formatSize(backupFiles.filter(f => selectedBackupFiles.includes(f.name)).reduce((a, b) => a + b.size, 0))})</p>}
                            </div>

                            {/* Conexión FTP */}
                            <div className="flex flex-col bg-gray-800/50 border border-gray-700 rounded p-3 min-h-0">
                                <h3 className="font-semibold text-sm mb-3 flex items-center gap-2 shrink-0"><Icon name="server" className="w-4 h-4" />Servidor NAS</h3>
                                <div className="flex-1 overflow-y-auto space-y-3">
                                    <div className="grid grid-cols-2 gap-2 text-xs">
                                        <div className="p-2 bg-gray-900/50 rounded"><span className="text-gray-400">Servidor:</span> <span className="text-cyan-400">revisteo.synology.me</span></div>
                                        <div className="p-2 bg-gray-900/50 rounded"><span className="text-gray-400">Usuario:</span> <span className="text-green-400">Flunky</span></div>
                                        <div className="p-2 bg-gray-900/50 rounded"><span className="text-gray-400">Carpeta:</span> <span className="text-yellow-400">/ZxTosec</span></div>
                                        <div className="p-2 bg-gray-900/50 rounded"><span className="text-gray-400">Protocolo:</span> <span className="text-purple-400">FTPS</span></div>
                                    </div>
                                    <div>
                                        <label className="block text-xs text-gray-400 mb-1">Contraseña</label>
                                        <div className="flex gap-2">
                                            <input type="password" value={ftpPassword} onChange={(e) => setFtpPassword(e.target.value)} placeholder="••••••••" className="flex-1 px-3 py-2 bg-gray-900 border border-gray-600 rounded" />
                                            <button onClick={testFtpConnection} className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded" title="Probar conexión"><Icon name="wifi" className="w-4 h-4" /></button>
                                        </div>
                                    </div>
                                    {connectionStatus && (<div className={`p-2 rounded text-xs ${connectionStatus.status === 'ok' ? 'bg-green-900/30 border border-green-500/30 text-green-300' : connectionStatus.status === 'error' ? 'bg-red-900/30 border border-red-500/30 text-red-300' : 'bg-blue-900/30 border border-blue-500/30 text-blue-300'}`}>{connectionStatus.message}</div>)}
                                    {currentUploadFile && (<div className="p-3 bg-blue-900/30 border border-blue-500/30 rounded"><p className="text-blue-300 mb-1 text-sm">Subiendo {currentUploadFile.index}/{currentUploadFile.total}</p><p className="text-white font-medium truncate">{currentUploadFile.name}</p><p className="text-gray-400 text-sm">{formatSize(currentUploadFile.size)}</p></div>)}
                                    {uploadProgress.length > 0 && (<div className="flex-1 overflow-y-auto space-y-1 max-h-64">{uploadProgress.map((p, i) => (<div key={i} className={`p-2 rounded text-xs flex items-center gap-2 ${p.success ? 'bg-green-900/30' : 'bg-red-900/30'}`}><span className={p.success ? 'text-green-400' : 'text-red-400'}>{p.success ? '✓' : '✗'}</span><span className="truncate flex-1">{p.filename}</span>{p.success && <span className="text-gray-400">{p.speed} MB/s</span>}{!p.success && <span className="text-red-400 text-xs">{p.error}</span>}</div>))}</div>)}
                                </div>
                                <button onClick={uploadToNAS} disabled={uploading || selectedBackupFiles.length === 0} className={`w-full px-4 py-3 rounded flex items-center justify-center gap-2 mt-3 shrink-0 text-lg font-bold ${uploading ? 'bg-gray-600' : 'bg-blue-600 hover:bg-blue-500'}`}>{uploading ? <Icon name="loader" className="w-5 h-5" /> : <Icon name="upload" className="w-5 h-5" />}{uploading ? 'Subiendo...' : `Subir ${selectedBackupFiles.length} archivo(s)`}</button>
                            </div>
                        </div></div>)
                        }
                    </div >

                    {showProcessModal && selectedFile && (<div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50"><div className="bg-gray-900 border border-purple-500/30 rounded max-w-3xl w-full max-h-[85vh] flex flex-col"><div className="p-3 border-b border-purple-500/20 flex justify-between"><div><h3 className="font-bold text-cyan-400 text-sm">Procesar</h3><p className="text-xs text-gray-400 truncate max-w-xl">{selectedFile.name}</p></div><button onClick={() => setShowProcessModal(false)}>✕</button></div><div className="flex-1 overflow-y-auto p-3">{['FE', 'TS'].map(col => (<div key={col} className="mb-3 border border-gray-700 rounded p-2"><h4 className="font-semibold text-xs mb-2 text-purple-400">{col}</h4><div className="space-y-1 max-h-48 overflow-y-auto">{selectedFile.suggested_paths?.[col]?.map((p, i) => (<label key={i} className="flex items-start gap-2 p-1.5 hover:bg-gray-800 rounded text-xs cursor-pointer"><input type="checkbox" checked={selectedDestinations[col]?.includes(p)} onChange={() => toggleDestination(col, p)} className="mt-0.5" /><span className="break-all">{p}</span></label>))}</div></div>))}</div><div className="p-3 border-t border-purple-500/20 flex justify-end gap-2"><button onClick={() => setShowProcessModal(false)} className="px-3 py-1 bg-gray-700 rounded text-xs">Cancelar</button><button onClick={processFile} disabled={processing} className="px-3 py-1 bg-green-600 rounded text-xs">{processing ? 'Copiando...' : 'Copiar'}</button></div></div></div>)}
                    
                    {/* Modal de Búsqueda Universal */}
                    {showSearchModal && (<div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50"><div className="bg-gray-900 border border-yellow-500/30 rounded max-w-4xl w-full max-h-[85vh] flex flex-col">
                        <div className="p-4 border-b border-yellow-500/20 flex items-center gap-3">
                            <Icon name="search" className="w-5 h-5 text-yellow-400" />
                            <div className="flex-1 relative">
                                <input type="text" placeholder="Buscar archivos en FE y TS..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && performSearch(searchQuery)} className="w-full px-3 py-2 pr-8 bg-gray-800 border border-gray-700 rounded text-sm" autoFocus />
                                {searchQuery && <button onClick={() => { setSearchQuery(''); setSearchResults([]); }} className="absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-white" title="Limpiar búsqueda">✕</button>}
                            </div>
                            <button onClick={() => performSearch(searchQuery)} disabled={searching} className="px-4 py-2 bg-yellow-600 hover:bg-yellow-500 rounded text-sm font-bold">{searching ? 'Buscando...' : 'Buscar'}</button>
                            <button onClick={() => setShowSearchModal(false)} className="px-3 py-2 bg-red-700 hover:bg-red-600 rounded text-sm">Cerrar</button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-4">
                            {searchResults.length === 0 && !searching && searchQuery && <p className="text-gray-500 text-center py-8">No se encontraron resultados</p>}
                            {searchResults.length > 0 && <p className="text-xs text-gray-400 mb-2">{searchResults.length} resultados encontrados</p>}
                            <div className="space-y-1">{searchResults.slice(0, 200).map((r, i) => (
                                <div key={i} className="p-2 bg-gray-800/50 border border-gray-700/50 hover:border-yellow-500/50 rounded text-xs flex items-center gap-2">
                                    <span className={`px-1.5 py-0.5 rounded text-xs font-bold ${r.collection === 'FE' ? 'bg-blue-600' : 'bg-cyan-600'}`}>{r.collection}</span>
                                    <Icon name="file" className="w-3 h-3 text-green-400" />
                                    <span className="flex-1 truncate font-medium cursor-pointer hover:text-yellow-400" onClick={() => navigateToSearchResult(r)} title="Ir a ubicación">{r.name}</span>
                                    <span className="text-gray-500 truncate max-w-xs hidden md:inline">{r.relative_path}</span>
                                    <div className="flex gap-1 ml-2">
                                        {isEmulable(r.name) && <button onClick={(e) => { e.stopPropagation(); emulateSearchResult(r); }} className="px-2 py-1 bg-green-600 hover:bg-green-500 rounded" title="Emular"><Icon name="play" className="w-3 h-3" /></button>}
                                        <button onClick={(e) => { e.stopPropagation(); copySearchResultToTemp(r); }} className="px-2 py-1 bg-orange-600 hover:bg-orange-500 rounded" title="Copiar a TEMP"><Icon name="copy" className="w-3 h-3" /></button>
                                        <button onClick={() => navigateToSearchResult(r)} className="px-2 py-1 bg-purple-600 hover:bg-purple-500 rounded" title="Ir a carpeta"><Icon name="folder" className="w-3 h-3" /></button>
                                    </div>
                                </div>
                            ))}</div>
                            {searchResults.length > 200 && <p className="text-xs text-yellow-500 mt-2 text-center">Mostrando 200 de {searchResults.length} resultados</p>}
                        </div>
                    </div></div>)}
                    {showFolderBrowser && (<div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50"><div className="bg-gray-900 border border-purple-500/30 rounded max-w-xl w-full max-h-[60vh] flex flex-col"><div className="p-3 border-b border-purple-500/20"><div className="flex justify-between mb-2"><h3 className="font-bold">Seleccionar destino</h3><button onClick={() => setShowFolderBrowser(false)}>✕</button></div><div className="flex gap-1">{['FE', 'TS'].map(c => (<button key={c} onClick={() => { setBrowserCollection(c); setBrowserPath([]); loadBrowserFolders(c, ''); }} className={`px-2 py-1 rounded text-xs ${browserCollection === c ? 'bg-purple-600' : 'bg-gray-700'}`}>{c}</button>))}</div></div><div className="px-3 py-1 bg-gray-800/50 text-xs"><button onClick={() => { setBrowserPath([]); loadBrowserFolders(browserCollection, ''); }} className="text-purple-400">{browserCollection}:/</button>{browserPath.map((s, i) => (<button key={i} onClick={() => { const np = browserPath.slice(0, i + 1); setBrowserPath(np); loadBrowserFolders(browserCollection, np.join('/')); }} className="text-purple-400">{s}/</button>))}</div><div className="flex-1 overflow-y-auto p-2 space-y-1">{browserFolders.map((f, i) => (<button key={i} onClick={() => { setBrowserPath([...browserPath, f.name]); loadBrowserFolders(browserCollection, [...browserPath, f.name].join('/')); }} className="w-full p-2 bg-gray-800/50 rounded hover:bg-gray-700/50 text-left text-xs flex items-center gap-2"><Icon name="folder" className="w-3 h-3 text-cyan-400" />{f.name}{f.has_subfolders && <span className="ml-auto text-gray-500">→</span>}</button>))}</div><div className="p-3 border-t border-purple-500/20 flex justify-between"><span className="text-xs bg-gray-800 px-2 py-1 rounded">{browserCollection}:{browserPath.join('/')}</span><div className="flex gap-1"><button onClick={() => setShowFolderBrowser(false)} className="px-2 py-1 bg-gray-700 rounded text-xs">Cancelar</button><button onClick={selectFolderForRule} className="px-2 py-1 bg-green-600 rounded text-xs">OK</button></div></div></div></div>)}

                    {showNewFolderModal && (<div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50"><div className="bg-gray-900 border border-purple-500/30 rounded p-4 w-96"><div className="flex justify-between mb-4"><h3 className="font-bold flex items-center gap-2"><Icon name="plus" className="w-4 h-4 text-green-400" />Nueva carpeta en {newFolderCollection}</h3><button onClick={() => setShowNewFolderModal(false)}>✕</button></div><p className="text-xs text-gray-400 mb-2">Ruta: {newFolderCollection}:/{(newFolderCollection === 'FE' ? fePath : tsPath).join('/')}/</p><input type="text" value={newFolderName} onChange={(e) => setNewFolderName(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && createNewFolder()} placeholder="Nombre de la carpeta" className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded text-sm mb-4" autoFocus /><div className="flex justify-end gap-2"><button onClick={() => setShowNewFolderModal(false)} className="px-3 py-1.5 bg-gray-700 rounded text-sm">Cancelar</button><button onClick={createNewFolder} disabled={!newFolderName.trim()} className={`px-3 py-1.5 rounded text-sm ${newFolderName.trim() ? 'bg-green-600 hover:bg-green-500' : 'bg-gray-600 cursor-not-allowed'}`}>Crear</button></div></div></div>)}
                    {showFileBrowser && (<div className="fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50"><div className="bg-gray-900 border border-yellow-500/30 rounded max-w-xl w-full max-h-[60vh] flex flex-col"><div className="p-3 border-b border-yellow-500/20"><div className="flex justify-between mb-2"><h3 className="font-bold text-yellow-400">Seleccionar archivo(s)</h3><button onClick={() => setShowFileBrowser(false)}>✕</button></div>{fileBrowserCollection !== 'TEMP' && <div className="flex gap-1 mb-2">{['FE', 'TS'].map(c => (<button key={c} onClick={() => { setFileBrowserCollection(c); setFileBrowserPath([]); loadFileBrowserContents(c, []); }} className={`px-2 py-1 rounded text-xs ${fileBrowserCollection === c ? 'bg-yellow-600' : 'bg-gray-700'}`}>{c}</button>))}</div>}{fileBrowserCollection !== 'TEMP' && <div className="px-2 py-1 bg-gray-800/50 text-xs mb-2"><button onClick={() => { setFileBrowserPath([]); loadFileBrowserContents(fileBrowserCollection, []); }} className="text-yellow-400">{fileBrowserCollection}:/</button>{fileBrowserPath.map((s, i) => (<button key={i} onClick={() => { const np = fileBrowserPath.slice(0, i + 1); setFileBrowserPath(np); loadFileBrowserContents(fileBrowserCollection, np); }} className="text-yellow-400">{s}/</button>))}</div>}<input type="text" value={fileSearchFilter} onChange={(e) => setFileSearchFilter(e.target.value)} placeholder="Filtrar..." className="w-full px-2 py-1 bg-gray-800 border border-gray-700 rounded text-xs" /></div><div className="flex-1 overflow-y-auto p-2 space-y-1">{fileBrowserItems.filter(it => !fileSearchFilter || it.name.toLowerCase().includes(fileSearchFilter.toLowerCase())).map((item, i) => (<button key={i} onClick={() => { if (item.type === 'folder') { setFileBrowserPath([...fileBrowserPath, item.name]); loadFileBrowserContents(fileBrowserCollection, [...fileBrowserPath, item.name]); } else { selectFileForRule(item); } }} className="w-full p-2 bg-gray-800/50 rounded hover:bg-gray-700/50 text-left text-xs flex items-center gap-2"><Icon name={item.type === 'folder' ? 'folder' : 'file'} className={`w-3 h-3 ${item.type === 'folder' ? 'text-cyan-400' : 'text-yellow-400'}`} />{item.name}{item.type === 'folder' && <span className="ml-auto text-gray-500">→</span>}</button>))}</div><div className="p-3 border-t flex justify-end"><button onClick={() => setShowFileBrowser(false)} className="px-2 py-1 bg-gray-700 rounded text-xs">Cerrar</button></div></div></div>)}
                </div >
            );
        }
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>

</html>